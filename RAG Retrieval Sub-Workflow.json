{
  "name": "Retrieval Sub-Workflow v0.1.8",
  "nodes": [
    {
      "parameters": {
        "content": "# State-of-the-Art RAG Agent (With Dynamic Hybrid Search & Context Expansion)",
        "height": 648,
        "width": 1052,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        14592,
        7520
      ],
      "id": "58048e90-ec46-47b1-86ef-c4e6096653c0",
      "name": "Sticky Note6"
    },
    {
      "parameters": {
        "content": "",
        "height": 648,
        "width": 840,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        13696,
        7504
      ],
      "id": "8cbb3fa7-84ed-4f19-a01c-a21293cf4d2d",
      "name": "Sticky Note18"
    },
    {
      "parameters": {
        "contextWindowLength": 10
      },
      "type": "@n8n/n8n-nodes-langchain.memoryPostgresChat",
      "typeVersion": 1.3,
      "position": [
        14960,
        7952
      ],
      "id": "e3ccf5cd-a982-4e6c-935a-da851d3e43d9",
      "name": "Supabase Short-Term Memory",
      "credentials": {
        "postgres": {
          "id": "tRlTzpjOmrCVSNLF",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "content": "## v2.3.3\nThis it the agentic inference workflow for both our SOTA RAG System and RAG At Scale System\n\nSOTA RAG Setup instructions here:\nhttps://community.theaiautomators.com/c/automation-templates/state-of-the-art-n8n-rag-agent\n\nRAG at Scale Setup instructions here:\nhttps://community.theaiautomators.com/c/automation-templates/rag-at-scale-system",
        "height": 244,
        "width": 580,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        13856,
        7872
      ],
      "id": "7de3f727-2f78-4d9e-a833-45371af729d5",
      "name": "Sticky Note21"
    },
    {
      "parameters": {
        "content": "# State-of-the-Art RAG Agent (With Long Term Memory)",
        "height": 648,
        "width": 2076,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        17136,
        7504
      ],
      "id": "03c619c2-a694-4929-9a7e-30a582d3dc05",
      "name": "Sticky Note20",
      "disabled": true
    },
    {
      "parameters": {
        "name": "Query_Knowledge_Graph",
        "description": "Call this to query data from our knowledge graph",
        "workflowId": {
          "__rl": true,
          "value": "A4BVrX5qYlJ7HUMI",
          "mode": "list",
          "cachedResultName": "TheAIAutomators.com - RAG Masterclass - Lesson 9 - SOTA - v2.0 Dev 0.3"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "query": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('query', ``, 'string') }}",
            "session_id": "={{ $json.sessionId }}",
            "type": "graph"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "query",
              "displayName": "query",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            },
            {
              "id": "type",
              "displayName": "type",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            },
            {
              "id": "session_id",
              "displayName": "session_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        }
      },
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "typeVersion": 2.1,
      "position": [
        18336,
        7984
      ],
      "id": "4ec94b8b-e091-4f73-b003-345e62a6a768",
      "name": "Query Knowledge Graph1",
      "retryOnFail": true,
      "maxTries": 5,
      "waitBetweenTries": 5000,
      "disabled": true
    },
    {
      "parameters": {
        "contextWindowLength": 10
      },
      "type": "@n8n/n8n-nodes-langchain.memoryPostgresChat",
      "typeVersion": 1.3,
      "position": [
        17680,
        7984
      ],
      "id": "77b9d649-506f-45f7-9745-ef0adabd7c25",
      "name": "Supabase Short-Term Memory2",
      "credentials": {
        "postgres": {
          "id": "tRlTzpjOmrCVSNLF",
          "name": "Postgres account"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.getzep.com/api/v2/graph/search",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"user_id\": \"{{ $json.user_id }}\",\n  \"query\": {{ JSON.stringify($('When chat message received').item.json.chatInput) }},\n  \"scope\": \"edges\",\n  \"limit\": 5,\n  \"search_filters\": {\n    \"min_relevance\": 0.7\n  }\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        17568,
        7728
      ],
      "id": "67db25dc-87e3-48ac-a4b5-1eead9c64bd9",
      "name": "Get Long Term Memories",
      "disabled": true
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [
        18480,
        7792
      ],
      "id": "4ee08aaf-604c-4f8a-8660-4b87fea3094e",
      "name": "Respond to Webhook",
      "disabled": true
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "c2e95998-ad5f-4676-b307-b91f5c4adaad",
              "name": "user_id",
              "value": "user1234",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        17312,
        7728
      ],
      "id": "0131c2ee-2778-4c34-86ac-09c11d4667f9",
      "name": "user_id",
      "disabled": true
    },
    {
      "parameters": {
        "content": "Note: This template uses n8n chat and by default, this long term memory is shared across all chat sessions. To maintain separate long term memories for different users, check out our community post here, as there are multiple approaches for this depending on how you're deploying the agent. ",
        "height": 192,
        "width": 256,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        17232,
        7904
      ],
      "typeVersion": 1,
      "id": "cf2cf6a5-bab3-46a6-afb4-c26a5a4168f0",
      "name": "Sticky Note25",
      "disabled": true
    },
    {
      "parameters": {
        "content": "## TODO\n### Add User ID here",
        "height": 232,
        "width": 232
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        17248,
        7648
      ],
      "id": "a29557cd-fe5b-451d-b1a7-b74c77bdb2fe",
      "name": "Sticky Note26",
      "disabled": true
    },
    {
      "parameters": {
        "descriptionType": "manual",
        "toolDescription": "Execute a SQL query on the tabular_document_rows table.\n\nInstructions:\n\nYou will always be querying based on a specific id.\n\nEach row in the table contains a row_data field (of type jsonb) that holds the data for that row, with keys matching the file schema defined in the record_manager table.\n\nThe record_manager_id is the id field from the record_manager table. Always filter based on this specific id when querying the tabular_document_rows table.\n\nWhen writing your SELECT clause, extract values from the row_data JSON using the ->> operator and cast them as needed (e.g., to numeric for calculations).\n\nItems within your SELECT needs to use the data within row_data field.\n\nExample query: Find maximum value for a field (e.g. \"profit\")\n\nSELECT MAX((row_data->>'profit')::numeric) AS max_profit\nFROM tabular_document_rows\nWHERE file_id = '123';\n\nExample query: Group and aggregate (e.g. total revenue by country)\n\nSELECT row_data->>'country' AS country,\n       SUM((row_data->>'revenue')::numeric) AS total_revenue\nFROM tabular_document_rows\nWHERE record_manager_id = '123'\nGROUP BY row_data->>'country';\n\nExample query: Group and aggregate (e.g. total revenue by country)\nSELECT row_data->>'salesperson' AS salesperson,\n       SUM((row_data->>'profit')::numeric) AS total_profit\nFROM tabular_document_rows\nWHERE record_manager_id = '123'\nGROUP BY row_data->>'salesperson';",
        "operation": "executeQuery",
        "query": "{{ $fromAI('sql_query') }}",
        "options": {}
      },
      "type": "n8n-nodes-base.postgresTool",
      "typeVersion": 2.5,
      "position": [
        18000,
        7984
      ],
      "id": "d260c6d1-91ff-4d99-80ed-9fcd2bab0888",
      "name": "Query Tabular Rows1",
      "credentials": {
        "postgres": {
          "id": "tRlTzpjOmrCVSNLF",
          "name": "Postgres account"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "descriptionType": "manual",
        "toolDescription": "Use this tool to fetch all available documents from the record_manager, this will include the table schema and the id",
        "operation": "select",
        "schema": {
          "__rl": true,
          "mode": "list",
          "value": "public"
        },
        "table": {
          "__rl": true,
          "value": "record_manager_v2",
          "mode": "list",
          "cachedResultName": "record_manager_v2"
        },
        "returnAll": true,
        "where": {
          "values": [
            {
              "column": "data_type",
              "value": "tabular"
            }
          ]
        },
        "options": {
          "outputColumns": [
            "id",
            "document_title",
            "schema"
          ]
        }
      },
      "type": "n8n-nodes-base.postgresTool",
      "typeVersion": 2.5,
      "position": [
        17840,
        7984
      ],
      "id": "dee1518c-681c-458b-89a9-f1e0245a54f9",
      "name": "Get datasets from record_manager1",
      "credentials": {
        "postgres": {
          "id": "tRlTzpjOmrCVSNLF",
          "name": "Postgres account"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.getzep.com/api/v2/users",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\"user_id\":\"user1234\"}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        18944,
        7840
      ],
      "id": "4fd847c4-7c83-4eb8-8f4f-4c1b29c3e500",
      "name": "Create Zep User",
      "disabled": true
    },
    {
      "parameters": {
        "content": "## TODO\n### Run this node once to manually create a Zep user",
        "height": 312,
        "width": 232
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        18880,
        7696
      ],
      "id": "0cb7379b-3cd8-4dd1-97af-c7404ac86345",
      "name": "Sticky Note27",
      "disabled": true
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "jfvPAjwlf1jVaW3Y",
          "mode": "list",
          "cachedResultName": "Zep - Update Long Term Memories - BLUEPRINT"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "session_id": "={{ $('When chat message received').item.json.sessionId }}",
            "user_id": "={{ $('user_id').item.json.user_id }}",
            "message_content": "={{ $('When chat message received').item.json.chatInput }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "session_id",
              "displayName": "session_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            },
            {
              "id": "user_id",
              "displayName": "user_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            },
            {
              "id": "message_content",
              "displayName": "message_content",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {
          "waitForSubWorkflow": false
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        18480,
        7584
      ],
      "id": "28eff85d-8c2f-4a53-be79-95d66d048385",
      "name": "Execute workflow - Save Zep long term memories",
      "disabled": true
    },
    {
      "parameters": {
        "public": true,
        "authentication": "n8nUserAuth",
        "initialMessages": "v0.1.7ðŸ‘‹\n",
        "options": {
          "responseMode": "lastNode"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.chatTrigger",
      "typeVersion": 1.3,
      "position": [
        14048,
        7680
      ],
      "id": "ed1dc4b5-ebe9-466c-a294-26737593a585",
      "name": "When chat message received",
      "webhookId": "5e442826-4547-4647-8d24-1641210f2a8e"
    },
    {
      "parameters": {
        "name": "Query_Knowledge_Graph",
        "description": "Call this to query data from our knowledge graph",
        "workflowId": {
          "__rl": true,
          "value": "suQZAl0QM15VyY3R",
          "mode": "list",
          "cachedResultUrl": "/workflow/suQZAl0QM15VyY3R",
          "cachedResultName": "TheAIAutomators.com - SOTA RAG AGENT - v2.3 Blueprint"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "query": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('query', ``, 'string') }}",
            "session_id": "={{ $json.sessionId }}",
            "type": "graph"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "query",
              "displayName": "query",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            },
            {
              "id": "type",
              "displayName": "type",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            },
            {
              "id": "session_id",
              "displayName": "session_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        }
      },
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "typeVersion": 2.1,
      "position": [
        16560,
        7952
      ],
      "id": "8ae7de5c-2450-46b2-a8d3-9fe7090e00b7",
      "name": "Query Knowledge Graph2",
      "retryOnFail": true,
      "maxTries": 5,
      "waitBetweenTries": 5000,
      "disabled": true
    },
    {
      "parameters": {
        "contextWindowLength": 10
      },
      "type": "@n8n/n8n-nodes-langchain.memoryPostgresChat",
      "typeVersion": 1.3,
      "position": [
        15888,
        7952
      ],
      "id": "d86907df-5c28-424a-b13c-dd67f9ef91f1",
      "name": "Supabase Short-Term Memory3",
      "credentials": {
        "postgres": {
          "id": "tRlTzpjOmrCVSNLF",
          "name": "Postgres account"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "descriptionType": "manual",
        "toolDescription": "Execute a SQL query on the tabular_document_rows table. \n\nInstructions:\n\nYou will always be querying based on a specific id.\n\nEach row in the table contains a row_data field (of type jsonb) that holds the data for that row, with keys matching the file schema defined in the record_manager table.\n\nThe record_manager_id is the id field from the record_manager table. Always filter based on this specific id when querying the tabular_document_rows table.\n\nWhen writing your SELECT clause, extract values from the row_data JSON using the ->> operator and cast them as needed (e.g., to numeric for calculations).\n\nWhen applying WHERE clauses, you should run SELECT DISTINCT queries (LIMIT 100) on the relevant fields first to understand the valid options. This applies even if the user provides a specific valueâ€”you must verify that the value exists in the data before using it.\n\nDo NOT run SELECT DISTINCT queries for ID columns.\n\nItems within your SELECT needs to use the data within row_data field.\n\nExample query: Find maximum value for a field (e.g. \"profit\")\n\nSELECT MAX((row_data->>'profit')::numeric) AS max_profit\nFROM tabular_document_rows\nWHERE file_id = '123';\n\nExample query: Group and aggregate (e.g. total revenue by country)\n\nSELECT row_data->>'country' AS country,\n       SUM((row_data->>'revenue')::numeric) AS total_revenue\nFROM tabular_document_rows\nWHERE record_manager_id = '123'\nGROUP BY row_data->>'country';\n\nExample query: Group and aggregate (e.g. total revenue by country)\nSELECT row_data->>'salesperson' AS salesperson,\n       SUM((row_data->>'profit')::numeric) AS total_profit\nFROM tabular_document_rows\nWHERE record_manager_id = '123'\nGROUP BY row_data->>'salesperson';",
        "operation": "executeQuery",
        "query": "{{ $fromAI('sql_query') }}",
        "options": {}
      },
      "type": "n8n-nodes-base.postgresTool",
      "typeVersion": 2.5,
      "position": [
        16208,
        7952
      ],
      "id": "a63d5f8f-80b9-4cf1-b80e-7a42c84a423c",
      "name": "Query Tabular Rows2",
      "credentials": {
        "postgres": {
          "id": "tRlTzpjOmrCVSNLF",
          "name": "Postgres account"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "descriptionType": "manual",
        "toolDescription": "Use this tool to fetch all available documents from the record_manager, this will include the table schema and the id",
        "operation": "select",
        "schema": {
          "__rl": true,
          "mode": "list",
          "value": "public"
        },
        "table": {
          "__rl": true,
          "value": "record_manager_v2",
          "mode": "list",
          "cachedResultName": "record_manager_v2"
        },
        "returnAll": true,
        "where": {
          "values": [
            {
              "column": "data_type",
              "value": "tabular"
            }
          ]
        },
        "options": {
          "outputColumns": [
            "id",
            "document_title",
            "schema"
          ]
        }
      },
      "type": "n8n-nodes-base.postgresTool",
      "typeVersion": 2.5,
      "position": [
        16048,
        7952
      ],
      "id": "5b17eecf-f72f-4d4c-91d4-4331e7a4c18c",
      "name": "Get datasets from record_manager2",
      "credentials": {
        "postgres": {
          "id": "tRlTzpjOmrCVSNLF",
          "name": "Postgres account"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "content": "# State-of-the-Art RAG Agent (With GraphRAG + NLQ)",
        "height": 648,
        "width": 1468,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        15648,
        7520
      ],
      "id": "acb30a3c-d61d-4a13-abd3-0879ee25b10b",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "content": "## TODO\n### Connect the Chat Trigger to your Agent of Choice",
        "height": 256,
        "width": 576
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        13856,
        7584
      ],
      "id": "a0b5308f-7433-46c0-bd25-ffe1bd8d63ec",
      "name": "Sticky Note29"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "claude-sonnet-4-5-20250929",
          "mode": "list",
          "cachedResultName": "Claude Sonnet 4.5"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
      "typeVersion": 1.3,
      "position": [
        15728,
        7952
      ],
      "id": "02a71b6d-5e3d-4142-ad45-70c84bfa5949",
      "name": "Anthropic Chat Model1",
      "credentials": {
        "anthropicApi": {
          "id": "UyAehXbUNQAWwZOs",
          "name": "Claude SEB"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "claude-sonnet-4-5-20250929",
          "mode": "list",
          "cachedResultName": "Claude Sonnet 4.5"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
      "typeVersion": 1.3,
      "position": [
        17520,
        7984
      ],
      "id": "c5baf36f-834e-4fe7-869f-090b46f16c80",
      "name": "Anthropic Chat Model2",
      "credentials": {
        "anthropicApi": {
          "id": "UyAehXbUNQAWwZOs",
          "name": "Claude SEB"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "description": "=Call this tool to query data from our knowledgebase using hybrid search (vector, lexical, ilike and fuzzy)\n\nYou can set different weights of this hybrid search depending on the type of query.\n\ndense_weight float DEFAULT 0.5,\nsparse_weight float DEFAULT 0.5,\nilike_weight float DEFAULT 0\nfuzzy_weight float DEFAULT 0\nfuzzy_threshold float DEFAULT 0.8\n\nFor semantic natural lanauge queries you can prioritise dense embeddings, \nFor technical terms and more traditional search you can priorize sparse lexical search\nFor exact matches for codes and IDs you can prioritze ilike wildcard matching\nFor typos that aren't picked up by semantic search, you can prioritize fuzzy matching\n\nIf looking for matches via ilike or fuzzy matches, the query should be extremely focused and short, as otherwise it will likely return zero results. (e.g. exact ID or code)\n\nAs pattern matching and fuzzy matching can add latency, I recommend defaulting this to zero unless you want to actually use it.\n\nTotal of the 4 weights much equal 1\n\nFuzzy Threshold adds significant latency should should be as high as possible - Default to 0.8",
        "workflowId": {
          "__rl": true,
          "value": "suQZAl0QM15VyY3R",
          "mode": "list",
          "cachedResultUrl": "/workflow/suQZAl0QM15VyY3R",
          "cachedResultName": "TheAIAutomators.com - SOTA RAG AGENT - v2.3 Blueprint"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "query": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('query', ``, 'string') }}",
            "session_id": "={{ $json.sessionId }}",
            "sparse_weight": "={{ $fromAI('sparse_weight', ``, 'number', 0.5) }}",
            "dense_weight": "={{ $fromAI('dense_weight', ``, 'number', 0.5) }}",
            "fuzzy_threshold": "={{ $fromAI('fuzzy_threshold', `this is the word similarity threshold in postgres - lower means more candidates however the call may time out`, 'number', 0.8) }}",
            "fuzzy_weight": "={{ $fromAI('fuzzy_weight', ``, 'number', 0) }}",
            "ilike_weight": "={{ $fromAI('ilike_weight', ``, 'number', 0) }}",
            "type": "hybrid"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "query",
              "displayName": "query",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "type",
              "displayName": "type",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "session_id",
              "displayName": "session_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "dense_weight",
              "displayName": "dense_weight",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            },
            {
              "id": "sparse_weight",
              "displayName": "sparse_weight",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            },
            {
              "id": "ilike_weight",
              "displayName": "ilike_weight",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            },
            {
              "id": "fuzzy_weight",
              "displayName": "fuzzy_weight",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            },
            {
              "id": "fuzzy_threshold",
              "displayName": "fuzzy_threshold",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        }
      },
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "typeVersion": 2.2,
      "position": [
        16384,
        7952
      ],
      "id": "2d172a06-9ed9-4729-a758-51cbf50303dd",
      "name": "Dynamic Hybrid Search1",
      "disabled": true
    },
    {
      "parameters": {
        "description": "=Call this tool to query data from our knowledgebase using hybrid search (vector, lexical, ilike and fuzzy)\n\nYou can set different weights of this hybrid search depending on the type of query.\n\ndense_weight float DEFAULT 0.5,\nsparse_weight float DEFAULT 0.5,\nilike_weight float DEFAULT 0\nfuzzy_weight float DEFAULT 0\nfuzzy_threshold float DEFAULT 0.8\n\nFor semantic natural lanauge queries you can prioritise dense embeddings, \nFor technical terms and more traditional search you can priorize sparse lexical search\nFor exact matches for codes and IDs you can prioritze ilike wildcard matching\nFor typos that aren't picked up by semantic search, you can prioritize fuzzy matching\n\nIf looking for matches via ilike or fuzzy matches, the query should be extremely focused and short, as otherwise it will likely return zero results. (e.g. exact ID or code)\n\nAs pattern matching and fuzzy matching can add latency, I recommend defaulting this to zero unless you want to actually use it.\n\nTotal of the 4 weights much equal 1\n\nFuzzy Threshold adds significant latency should should be as high as possible - Default to 0.8",
        "workflowId": {
          "__rl": true,
          "value": "BBep2uTA4ZltoqZF",
          "mode": "list",
          "cachedResultName": "TheAIAutomators.com - SOTA RAG AGENT - v2.2 Active"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "query": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('query', ``, 'string') }}",
            "session_id": "={{ $json.sessionId }}",
            "sparse_weight": "={{ $fromAI('sparse_weight', ``, 'number', 0.5) }}",
            "dense_weight": "={{ $fromAI('dense_weight', ``, 'number', 0.5) }}",
            "fuzzy_threshold": "={{ $fromAI('fuzzy_threshold', `this is the word similarity threshold in postgres - lower means more candidates however the call may time out`, 'number', 0.8) }}",
            "fuzzy_weight": "={{ $fromAI('fuzzy_weight', ``, 'number', 0) }}",
            "ilike_weight": "={{ $fromAI('ilike_weight', ``, 'number', 0) }}",
            "type": "hybrid"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "query",
              "displayName": "query",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "type",
              "displayName": "type",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "session_id",
              "displayName": "session_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "dense_weight",
              "displayName": "dense_weight",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            },
            {
              "id": "sparse_weight",
              "displayName": "sparse_weight",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            },
            {
              "id": "ilike_weight",
              "displayName": "ilike_weight",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            },
            {
              "id": "fuzzy_weight",
              "displayName": "fuzzy_weight",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            },
            {
              "id": "fuzzy_threshold",
              "displayName": "fuzzy_threshold",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        }
      },
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "typeVersion": 2.2,
      "position": [
        18176,
        7984
      ],
      "id": "752db5c4-05a6-4c63-bfe3-10e7e6765b42",
      "name": "Dynamic Hybrid Search2",
      "disabled": true
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "record_manager_v2",
        "limit": 1,
        "filters": {
          "conditions": [
            {
              "keyName": "doc_id",
              "condition": "eq",
              "keyValue": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('conditions0_Field_Value', ``, 'string') }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabaseTool",
      "typeVersion": 1,
      "position": [
        15280,
        7952
      ],
      "id": "a3a90ed7-0177-4e3a-ae63-7d5ac8ec1944",
      "name": "Fetch Document Hierarchy",
      "credentials": {
        "supabaseApi": {
          "id": "JXvQLWfqIjdcMyqm",
          "name": "Supabase B5rman"
        }
      }
    },
    {
      "parameters": {
        "toolDescription": "Based on the most promising chunks retrieved from the knowledgebase, use this tool to expand out the context by fetching neighbouring chunks, parent chunks etc\n\nThe body of this call must be in this format and the values you need are in the chunk metadata. You can retrieve chunks from one or multiple documents if you like\n[\n    {\n      doc_id: \"doc-id-12345-abcde\",\n      chunk_ranges: [[0, 5]]\n    },\n    {\n      doc_id: \"another-doc-id-12345\",\n      chunk_ranges: [[10, 15], [20, 25]]\n    }\n  ]\n",
        "method": "POST",
        "url": "https://mgistrmwhxccyuchokbh.supabase.co/functions/v1/context-expansion",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('JSON', ``, 'json') }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequestTool",
      "typeVersion": 4.2,
      "position": [
        15456,
        7952
      ],
      "id": "bcb25e6a-e757-41df-86cc-7b00b2fff29f",
      "name": "Context Expansion",
      "credentials": {
        "supabaseApi": {
          "id": "JXvQLWfqIjdcMyqm",
          "name": "Supabase B5rman"
        }
      }
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "record_manager_v2",
        "limit": 1,
        "filters": {
          "conditions": [
            {
              "keyName": "doc_id",
              "condition": "eq",
              "keyValue": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('conditions0_Field_Value', ``, 'string') }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabaseTool",
      "typeVersion": 1,
      "position": [
        16720,
        7952
      ],
      "id": "cd1f5079-6f56-4a26-9a00-33aed6a57ec1",
      "name": "Fetch Document Hierarchy1",
      "credentials": {
        "supabaseApi": {
          "id": "JXvQLWfqIjdcMyqm",
          "name": "Supabase B5rman"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "toolDescription": "Based on the most promising chunks retrieved from the knowledgebase, use this tool to expand out the context by fetching neighbouring chunks, parent chunks etc\n\nThe body of this call must be in this format and the values you need are in the chunk metadata. You can retrieve chunks from one or multiple documents if you like\n[\n    {\n      doc_id: \"doc-id-12345-abcde\",\n      chunk_ranges: [[0, 5]]\n    },\n    {\n      doc_id: \"another-doc-id-12345\",\n      chunk_ranges: [[10, 15], [20, 25]]\n    }\n  ]\n",
        "method": "POST",
        "url": "https://iwcionhpeltdhfrtimtp.supabase.co/functions/v1/context-expansion",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('JSON', ``, 'json') }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequestTool",
      "typeVersion": 4.2,
      "position": [
        16896,
        7952
      ],
      "id": "ecf7fa43-0522-4a29-b471-3d28328affe2",
      "name": "Context Expansion1",
      "disabled": true
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "record_manager_v2",
        "limit": 1,
        "filters": {
          "conditions": [
            {
              "keyName": "doc_id",
              "condition": "eq",
              "keyValue": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('conditions0_Field_Value', ``, 'string') }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabaseTool",
      "typeVersion": 1,
      "position": [
        18496,
        7984
      ],
      "id": "34513430-d695-4d96-94d3-822ca49aa260",
      "name": "Fetch Document Hierarchy2",
      "credentials": {
        "supabaseApi": {
          "id": "JXvQLWfqIjdcMyqm",
          "name": "Supabase B5rman"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "toolDescription": "Based on the most promising chunks retrieved from the knowledgebase, use this tool to expand out the context by fetching neighbouring chunks, parent chunks etc\n\nThe body of this call must be in this format and the values you need are in the chunk metadata. You can retrieve chunks from one or multiple documents if you like\n[\n    {\n      doc_id: \"doc-id-12345-abcde\",\n      chunk_ranges: [[0, 5]]\n    },\n    {\n      doc_id: \"another-doc-id-12345\",\n      chunk_ranges: [[10, 15], [20, 25]]\n    }\n  ]\n",
        "method": "POST",
        "url": "https://iwcionhpeltdhfrtimtp.supabase.co/functions/v1/context-expansion",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('JSON', ``, 'json') }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequestTool",
      "typeVersion": 4.2,
      "position": [
        18672,
        7984
      ],
      "id": "91d73df7-abfb-42ef-a36e-85b224b8f0aa",
      "name": "Context Expansion2",
      "disabled": true
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $('When chat message received').item.json.chatInput }}",
        "options": {
          "systemMessage": "=# Role\n\nYou are an AI assistant responding to a user's query based STRICTLY on the information available in the knowledgebase. You are a factual retrieval system, not a creative assistant.\n\n# Goal\n\nYou are tasked with creating and executing a retrieval strategy to best answer the user's question.\n\nThe output should be a well-researched response based on the output from these tools ONLY, following the Operating Procedures and Response Rules below.\n\nYou must consider both the conversation history and the current query.\n\nYour goal is to provide a fully grounded, accurate answer based on the output from these tools ONLY.\n\n# Standard Operating Procedure\n\n1. Based on your retrieval strategy, pass relevant query(s) to the dynamic hybrid search to narrow the search and retrieve candidate chunks\n2. Based on the most relevant chunk(s); Trigger the Fetch Document Hierarchy Tool to load the source Document's Structure\n3. Based on this document structure (which includes chunk ranges) along with any relevant child_ranges and parent_ranges from the retrieved chunks, trigger the Context Expansion tool to expand your insight into the document.\n\nOnce you've collected enough information, then answer the question, based on the info in context.\n\n# Response Rules\n\n- Ideal target format and length: Multiple Paragraphs\n- Use markdown formatting with appropriate section headings\n- Always respond in the same language the user writes in. If the user writes in English, respond in English. If the user writes in Dutch, respond in Dutch. Never switch languages unless the user does.\n- If there are images provided from the retrieved information, you should return this in markdown format.\n- Ensure the response maintains continuity with the conversation history.\n\n## Grounding & Citation Rules (CRITICAL)\n\n- Every factual claim MUST be supported by a specific retrieved chunk. Cite inline using [Document Name, p.X] format.\n- Do NOT infer, extrapolate, or combine information in ways not directly supported by the retrieved text.\n- Do NOT add background knowledge, general explanations, or context that is not present in the retrieved documents.\n- If the retrieved information only partially answers the question, explicitly state what you found and what remains unanswered. Say: \"Based on the available documents, I can answer X but not Y.\"\n- If multiple sources provide conflicting information, present both perspectives with their citations rather than choosing one.\n- Do NOT paraphrase loosely. Stay close to the original wording of the source material.\n- If you cannot answer the question using the provided information or if no information is returned from the tools, say: \"I don't have enough information in the knowledge base to answer this question.\"\n\n## References\n\n- List between 1-5 important reference sources at the end under a \"References\" section.\n- Provide Document Names and Page Numbers where these sources appear â€” this is in the chunk metadata.\n- Only list sources you actually cited in your response."
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.9,
      "position": [
        14912,
        7696
      ],
      "id": "0f67afce-37b6-4d88-b237-78c6eb182a31",
      "name": "Agentic RAG 1",
      "retryOnFail": true,
      "maxTries": 5
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $('When chat message received').item.json.chatInput }}",
        "options": {
          "systemMessage": "=# Role\n\nYou are an AI assistant responding to a user's query based on the information provided by multiple knowledgebases - Hybrid Search, Knowledge Graph and Structured datasets.\n\n# Goal\n\nYou are tasked with creating and executing a retrieval strategy to best answer the users question.\n\nThe output should be a well-reserached response to the users query based on the output from these tools and to follow the Operating Procedures and Response Rules as set about below.\n\nYou must consider both the conversation history and the current query.\n\nYour goal is to provide a fully grounded, accurate answer based on the output from these tools ONLY.\n\n# Standard Operating Procedure\n\nBased on your retrieval strategy\n\n## Hybrid Search & Context Expansion\n\n1. Pass relevant query(s) to the dynamic hybrid search to narrow the search and retrieve candidate chunks\n\n2. Based on the most relevant chunk(s); Trigger the Fetch Document Hierarchy Tool to load the source Documents Structure\n\n3. Based on this document structure (which includes chunk ranges) along with any relevant child_ranges and parent_ranges from the retrieved chunks, trigger the Context Expansion tool to expand your insight into the document.\n\n## Tabular Data\n\nIf the question involves tabular dataâ€”such as calculating sums, averages, or finding maximum valuesâ€”the vector store and graph tools may be unreliable. \n\nIn that case, start by reviewing the available datasets, identify the ones most likely to contain the answer, and then construct a SQL query to analyze them.\n\n## Knowledge Graph\n\nIf you are asked questions that you think would be best answered with insights from a knowledge graph then please seach the graph\n\n---Response Rules---\n\n- Ideal target format and length: Multiple Paragraphs\n- Use markdown formatting with appropriate section headings\n- Always respond in the same language the user writes in. If the user writes in English, respond in English. If the user writes in Dutch, respond in Dutch. Never switch languages unless the user does.\n- If there are images provided from the retrieved information, you should return this in markdown format.\n- Ensure the response maintains continuity with the conversation history.\n- List between 1-5 important reference sources at the end under \"References\" section. (Mark the source as (KB) for Knowledgebase, (GR) for Graph or (DB) for Database). If information is from chunks, then provide Document Names and Page Numbers that these sources appear in the documents - this is in the chunk metadata.\n- Do not make anything up. \n- Do not include information not provided by the Knowledge Bases.\n- If you cannot answer the question using the provided information or if no information is returned from the tools, say \"Sorry I don't know\"."
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.9,
      "position": [
        16096,
        7696
      ],
      "id": "37f213e5-dc62-4d6d-8ac3-49785681d5c0",
      "name": "Agentic RAG 2",
      "retryOnFail": true,
      "maxTries": 5,
      "disabled": true
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $('When chat message received').item.json.chatInput }}",
        "options": {
          "systemMessage": "=# Role\n\nYou are an AI assistant responding to a user's query based on the information provided by multiple knowledgebases - Hybrid Search, Knowledge Graph and Structured datasets.\n\n# Goal\n\nYou are tasked with creating and executing a retrieval strategy to best answer the users question.\n\nThe output should be a well-reserached response to the users query based on the output from these tools and to follow the Operating Procedures and Response Rules as set about below.\n\nYou must consider both the conversation history and the current query.\n\nYour goal is to provide a fully grounded, accurate answer based on the output from these tools ONLY.\n\n# Standard Operating Procedure\n\nBased on your retrieval strategy\n\n## Hybrid Search & Context Expansion\n\n1. Pass relevant query(s) to the dynamic hybrid search to narrow the search and retrieve candidate chunks\n\n2. Based on the most relevant chunk(s); Trigger the Fetch Document Hierarchy Tool to load the source Documents Structure\n\n3. Based on this document structure (which includes chunk ranges) along with any relevant child_ranges and parent_ranges from the retrieved chunks, trigger the Context Expansion tool to expand your insight into the document.\n\n## Tabular Data\n\nIf the question involves tabular dataâ€”such as calculating sums, averages, or finding maximum valuesâ€”the vector store and graph tools may be unreliable. \n\nIn that case, start by reviewing the available datasets, identify the ones most likely to contain the answer, and then construct a SQL query to analyze them.\n\n## Knowledge Graph\n\nIf you are asked questions that you think would be best answered with insights from a knowledge graph then please seach the graph\n\n---Response Rules---\n\n- Ideal target format and length: Multiple Paragraphs\n- Use markdown formatting with appropriate section headings\n- Always respond in the same language the user writes in. If the user writes in English, respond in English. If the user writes in Dutch, respond in Dutch. Never switch languages unless the user does.\n- If there are images provided from the retrieved information, you should return this in markdown format.\n- Ensure the response maintains continuity with the conversation history.\n- List between 1-5 important reference sources at the end under \"References\" section. (Mark the source as (KB) for Knowledgebase, (GR) for Graph or (DB) for Database). If information is from chunks, then provide Document Names and Page Numbers that these sources appear in the documents - this is in the chunk metadata.\n- Do not make anything up. \n- Do not include information not provided by the Knowledge Bases.\n- If you cannot answer the question using the provided information or if no information is returned from the tools, say \"Sorry I don't know\".\n\n{{\n(() => {\n  const raw = $json.data;\n  if (raw == null) return '';\n\n  const toText = v => (typeof v === 'string' ? v : JSON.stringify(v));\n  const rawText = toText(raw);\n  const cleaned = rawText.replace(/[\\u0000-\\u001F\\u007F]/g, '').trim();\n  if (!cleaned || cleaned === '{}' || cleaned === '[]') return '';\n\n  // Parse only if the cleaned text looks like JSON\n  let obj = raw;\n  if (typeof raw === 'string') {\n    const first = cleaned[0];\n    if (first === '{' || first === '[') {\n      try { obj = JSON.parse(cleaned); } catch { return ''; }\n    } else {\n      return '';\n    }\n  }\n\n  // Support either { edges: [...] } or a bare array of edges\n  const edges = Array.isArray(obj?.edges) ? obj.edges : (Array.isArray(obj) ? obj : []);\n  if (!edges.length) return '';\n\n  const facts = [...new Set(\n    edges\n      .map(e => (e && typeof e.fact === 'string') ? e.fact.replace(/\\s+/g, ' ').trim() : '')\n      .filter(Boolean)\n  )];\n\n  return facts.length\n    ? \"---User Information---\\nThis is information about the user:\\n\" + facts.map(f => \"- \" + f).join(\"\\n\")\n    : '';\n})()\n}}"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.9,
      "position": [
        17776,
        7728
      ],
      "id": "e89c8600-aad3-4eb4-8207-ebbdcf52d656",
      "name": "Agentic RAG 3",
      "retryOnFail": true,
      "maxTries": 5,
      "disabled": true
    },
    {
      "parameters": {
        "inputSource": "passthrough"
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        14704,
        8416
      ],
      "id": "e3de5483-93ec-461d-9484-4c2210fef6d1",
      "name": "When Executed by Another Workflow",
      "alwaysOutputData": false
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/embeddings",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "openAiApi",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "input",
              "value": "={{ $('When Executed by Another Workflow').item.json.query }}"
            },
            {
              "name": "model",
              "value": "text-embedding-3-small"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        16624,
        8448
      ],
      "id": "528a2c95-2947-450b-a475-8c79cbe05c77",
      "name": "Generate Embedding From Query",
      "credentials": {
        "openAiApi": {
          "id": "r6dwaEmQxKEvrskM",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.cohere.com/v2/rerank",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "accept",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"rerank-v3.5\",\n  \"query\": \"{{ $('When Executed by Another Workflow').first().json.query }}\",\n  \"top_n\": 10,\n  \"documents\": {{ JSON.stringify($json.documents) }}\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        17680,
        8416
      ],
      "id": "82eeee1f-5f41-4ef7-ac47-80e56e62a2b3",
      "name": "Rerank with Cohere 3.5",
      "credentials": {
        "httpHeaderAuth": {
          "id": "lSFkzmpI1ZAMZqHr",
          "name": "Cohere"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// --- This Code Node extracts 'content' from multiple input items ---\n\n// Step 1: Use .map() to iterate over ALL incoming items ($input.all()).\n// For each item, access its 'json' property, and then the 'content' field within that.\nconst contentArray = $input.all().map(item => {\n  // Basic safety check: ensure item.json and item.json.content exist.\n  // Return null or an empty string if not found, otherwise return the content.\n  // Adjust the fallback value (null) if needed.\n  return item.json?.content ?? null;\n});\n\n// Step 2: Filter out any potential null values if an item was missing content (optional)\n// If you are certain all items will have content, you can skip this filter.\nconst validContentArray = contentArray.filter(content => content !== null);\n\n// Step 3: Return the result as a *single* new n8n item.\n// This item contains your final array of strings under the 'documents' key.\nreturn [{\n  json: {\n    // Use validContentArray if you filtered, otherwise use contentArray\n    documents: validContentArray\n    // documents: contentArray // <-- Use this if you didn't filter\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        17440,
        8416
      ],
      "id": "fee7fab9-6c2a-4555-a319-dfcc2a5b1945",
      "name": "Create Array"
    },
    {
      "parameters": {
        "jsCode": "// --- Code Node to Reorder Items Based on Rerank Results (WITH METADATA) ---\n\n// --- Step 1: Get Data from Input Nodes ---\n\n// Get the ORIGINAL full items (with content + metadata) from the node that outputs them\n// Replace 'Vector Store' with the actual name of your node that outputs the chunks\nconst originalFullItems = $('Trigger Dynamic Hybrid Search').all();\n\n// Get the rerank results array from the Cohere Rerank node\nconst rerankOrderInfo = $input.first().json.results;\n\n// --- Step 2: Validate Inputs ---\nif (!Array.isArray(originalFullItems) || originalFullItems.length === 0) {\n  throw new Error(\"Could not retrieve original items with metadata. Check the source node name.\");\n}\n\nif (!Array.isArray(rerankOrderInfo) || rerankOrderInfo.length === 0) {\n  if (originalFullItems.length !== 0) {\n    throw new Error(\"Could not get valid rerank results from the input node.\");\n  }\n}\n\n// --- Step 3: Reorder the FULL Items (content + metadata) ---\nlet sortedItems = [];\n\nif (rerankOrderInfo && rerankOrderInfo.length > 0 && originalFullItems && originalFullItems.length > 0) {\n  sortedItems = rerankOrderInfo.map(rankInfo => {\n    const originalIndex = rankInfo.index;\n    \n    // Check if the index is valid\n    if (originalIndex !== undefined && originalIndex !== null && \n        originalIndex >= 0 && originalIndex < originalFullItems.length) {\n      \n      // Get the full original item (with all metadata)\n      const originalItem = originalFullItems[originalIndex].json;\n      \n      // Optionally add the rerank score to the item\n      return {\n        ...originalItem,\n        rerank_score: rankInfo.relevance_score // Cohere's relevance score\n      };\n    } else {\n      console.error(`Error: Rerank index ${originalIndex} is invalid. Skipping.`);\n      return null;\n    }\n  }).filter(item => item !== null);\n} else {\n  sortedItems = [];\n  console.log(\"Input data is empty, resulting in empty sorted output.\");\n}\n\n// --- Step 4: Return the Sorted Items ---\n// Option A: Return as multiple n8n items (one per document)\nreturn sortedItems.map(item => ({ json: item }));\n\n// Option B: Return as single item with array (uncomment if preferred)\n// return [{ json: { sortedDocuments: sortedItems } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        17904,
        8416
      ],
      "id": "bac969d0-1ada-4b72-886b-ea33b4c5f2e3",
      "name": "Return Reordered Items1"
    },
    {
      "parameters": {
        "content": "## Hybrid Search",
        "height": 552,
        "width": 536,
        "color": 6
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        16576,
        8272
      ],
      "id": "1413c48a-e23b-4566-9b2a-b155e565bd50",
      "name": "Sticky Note11"
    },
    {
      "parameters": {
        "content": "## Reranking",
        "height": 552,
        "width": 1044,
        "color": 6
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        17136,
        8272
      ],
      "id": "0a079560-dee2-4bf4-bee3-f2bcb5ebcbf3",
      "name": "Sticky Note12"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "71326cd6-1316-4b5e-bf34-0d0b3c086005",
              "leftValue": "={{ $('Trigger Dynamic Hybrid Search').item.json.keys().length}}",
              "rightValue": 0,
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        17168,
        8416
      ],
      "id": "385fe667-26ec-4f06-9aab-5bbe17ab40c2",
      "name": "If3",
      "alwaysOutputData": false
    },
    {
      "parameters": {
        "jsCode": "return [{\n  message: \"no documents found\" \n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        17440,
        8640
      ],
      "id": "a376ed37-b6b1-4ed6-89ea-b4e8d2d533e4",
      "name": "Code"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.type }}",
                    "rightValue": "hybrid",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "322d7a20-e584-4a2c-ad39-987298dabdf1"
                  }
                ],
                "combinator": "and"
              }
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "4c020ce0-c212-4e62-9c42-863f0358d065",
                    "leftValue": "={{ $json.type }}",
                    "rightValue": "graph",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              }
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        14896,
        8416
      ],
      "id": "0f563eaa-8067-4cb2-81e5-778657891da8",
      "name": "Switch2"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://YOUR_LIGHTRAG_URL/query",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"query\": \"{{ $('When Executed by Another Workflow').item.json.query }}\",\n  \"mode\": \"hybrid\",\n  \"only_need_context\": true,\n  \"only_need_prompt\": false,\n  \"response_type\": \"multiple paragraphs\",\n  \"top_k\": 20,\n  \"chunk_top_k\": 1,\n  \"max_entity_tokens\": 10000,\n  \"max_relation_tokens\": 10000,\n  \"max_total_tokens\": 32000,\n  \"enable_rerank\": false\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        15600,
        9024
      ],
      "id": "dc77dd73-db37-4d20-8559-4fa0ce72951c",
      "name": "Query Graph",
      "credentials": {
        "httpHeaderAuth": {
          "id": "lSFkzmpI1ZAMZqHr",
          "name": "Cohere"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "// Loop over input items and extract everything before \"-----Document Chunks(DC)-----\"\nfor (const item of $input.all()) {\n\n  const intro = \"The following entities and relationships were retrived.\\n\\n\"\n  const outro = \"-----How to use this data-----\\n\\nWhen considering relationships with timestamps:\\n\\nEach relationship has a \\\"created_at\\\" timestamp indicating when we acquired this knowledge. When encountering conflicting relationships, consider both the semantic content and the timestamp. Don't automatically prefer the most recently created relationships - use judgment based on the context. For time-specific queries, prioritize temporal information in the content before considering creation timestamps\"\n  \n  // Get the input string - adjust this based on where your string is located\n  const inputString = item.json.response; // Change 'response' to your actual field name\n  \n  // Define the substring to search for\n  const separator = \"-----Document Chunks(DC)-----\";\n  \n  // Find the position of the separator\n  const separatorIndex = inputString.indexOf(separator);\n  \n  let extractedContent = \"\";\n  \n  if (separatorIndex !== -1) {\n    // Extract everything before the separator\n    extractedContent = inputString.substring(0, separatorIndex);\n  } else {\n    // If separator not found, return the entire string\n    extractedContent = inputString;\n  }\n  \n  // Add the extracted content to the item\n  item.json.response = intro + extractedContent + outro;\n\n}\n\nreturn $input.all();"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        15840,
        9024
      ],
      "id": "2e930dfc-f492-4a19-9b08-67e1a72044c2",
      "name": "Tidy up response",
      "disabled": true
    },
    {
      "parameters": {
        "content": "## Graph Search",
        "height": 348,
        "width": 800,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        15456,
        8880
      ],
      "id": "276eb8c1-58a6-4d49-83c4-42c66059605c",
      "name": "Sticky Note13"
    },
    {
      "parameters": {
        "content": "## Advanced Metadata Filtering",
        "height": 552,
        "width": 1104,
        "color": 6
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        15456,
        8272
      ],
      "id": "bdc004d6-00af-4be9-97ab-e161867aa252",
      "name": "Sticky Note16"
    },
    {
      "parameters": {
        "options": {
          "groupMessages": false
        }
      },
      "type": "@n8n/n8n-nodes-langchain.memoryManager",
      "typeVersion": 1.1,
      "position": [
        15152,
        8384
      ],
      "id": "62726327-340d-4d02-b9b1-41d2b79ab54f",
      "name": "Chat Memory Manager",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "chatgpt-4o-latest",
          "mode": "list",
          "cachedResultName": "chatgpt-4o-latest"
        },
        "options": {
          "temperature": 0.4
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        15952,
        8640
      ],
      "id": "d5eff8ca-287e-47fd-938a-62519a500d9f",
      "name": "OpenAI Chat Model4",
      "credentials": {
        "openAiApi": {
          "id": "r6dwaEmQxKEvrskM",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=# User Query\n{{ $('When Executed by Another Workflow').first().json.query }}\n\n# Conversation History (if any)\n{{ JSON.stringify($('Chat Memory Manager').first().json) }}",
        "hasOutputParser": true,
        "messages": {
          "messageValues": [
            {
              "message": "=# Task\n\nYour task is to consider the following user query and then consider the following metadata keys with example values that we have that we can limit our result set from.\n\n# Metadata Filters and Possible Values\n\n{{ $json.filterPromptInstructions }}\n\n# Metadata Operators\n\nThe following operators are allowed:\n\n>\n<\n=\n!=\n>=\n<=\nIN\nNOT IN\n\nIF IN or NOT IN are provided, then an array of values must be provided.\n\nNow output a filter array with relevant filters with the following example format. The below filter_categories are just for exampe purposes. Use the \"Metadata Filters and Possible Values\" list above for the list of allowed filters.\n\n[\n    \"filter\": {\n      \"$and\": [\n        {\n          \"category\": {\n            \"operator\": \"IN\",\n            \"value\": [\n              \"F1\",\n              \"Rally\"\n            ]\n          }\n        },\n        {\n          \"year\": {\n            \"operator\": \">\",\n            \"value\": 2024\n          }\n        }\n      ]\n    }\n]\n\nIf the query does not have relevant metadatafilters, then do not output any ... for example\n\n{\n  \"filter\": {}\n}\n\nIf there is only 1 relevant metadafilter, then just output that ... for example\n\n[\n    \"filter\": {\n      \"$and\": [\n        {\n          \"motorsport_category\": {\n            \"operator\": \"IN\",\n            \"value\": [\n              \"F1\",\n              \"Rally\"\n            ]\n          }\n        }\n      ]\n    }\n]\n\nOnly output in JSON\n\nNote: Today's date is {{ $now }}"
            }
          ]
        }
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [
        16176,
        8400
      ],
      "id": "14e810c2-7125-42c7-8ad5-378ad03fbfad",
      "name": "Prep Metadata1",
      "retryOnFail": true,
      "maxTries": 5
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"FlexibleFilterObject\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"filter\": {\n      \"type\": \"object\",\n      \"oneOf\": [\n        {\n          \"required\": [\"$and\"],\n          \"properties\": {\n            \"$and\": {\n              \"type\": \"array\",\n              \"items\": { \"$ref\": \"#/definitions/condition\" }\n            }\n          },\n          \"additionalProperties\": false\n        },\n        {\n          \"required\": [\"$or\"],\n          \"properties\": {\n            \"$or\": {\n              \"type\": \"array\",\n              \"items\": { \"$ref\": \"#/definitions/condition\" }\n            }\n          },\n          \"additionalProperties\": false\n        },\n        {\n          \"properties\": {},\n          \"additionalProperties\": false\n        }\n      ]\n    }\n  },\n  \"required\": [\"filter\"],\n  \"definitions\": {\n    \"condition\": {\n      \"oneOf\": [\n        {\n          \"type\": \"object\",\n          \"required\": [\"field\", \"operator\", \"value\"],\n          \"properties\": {\n            \"field\": { \"type\": \"string\" },\n            \"operator\": {\n              \"type\": \"string\",\n              \"enum\": [\"=\", \"!=\", \">\", \"<\", \">=\", \"<=\", \"IN\", \"NOT IN\"]\n            },\n            \"value\": {\n              \"oneOf\": [\n                { \"type\": \"string\" },\n                { \"type\": \"number\" },\n                {\n                  \"type\": \"array\",\n                  \"items\": { \"type\": [\"string\", \"number\"] }\n                }\n              ]\n            }\n          },\n          \"additionalProperties\": false\n        },\n        {\n          \"type\": \"object\",\n          \"minProperties\": 1,\n          \"maxProperties\": 1,\n          \"patternProperties\": {\n            \"^.+$\": {\n              \"type\": \"object\",\n              \"required\": [\"operator\", \"value\"],\n              \"properties\": {\n                \"operator\": {\n                  \"type\": \"string\",\n                  \"enum\": [\"=\", \"!=\", \">\", \"<\", \">=\", \"<=\", \"IN\", \"NOT IN\"]\n                },\n                \"value\": {\n                  \"oneOf\": [\n                    { \"type\": \"string\" },\n                    { \"type\": \"number\" },\n                    {\n                      \"type\": \"array\",\n                      \"items\": { \"type\": [\"string\", \"number\"] }\n                    }\n                  ]\n                }\n              },\n              \"additionalProperties\": false\n            }\n          },\n          \"additionalProperties\": false\n        }\n      ]\n    }\n  }\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.2,
      "position": [
        16336,
        8624
      ],
      "id": "676846a2-4f67-4851-a016-6ee3caed4a56",
      "name": "Structured Output Parser"
    },
    {
      "parameters": {
        "content": "# Retrieval Sub-Workflow",
        "height": 552,
        "width": 840,
        "color": 6
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        14592,
        8272
      ],
      "id": "b602beda-2050-4743-ba88-b7c2d49cddcf",
      "name": "Sticky Note17"
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "metadata_fields"
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        15520,
        8416
      ],
      "id": "ba3e0221-d13f-412b-8d75-2c0063475ccc",
      "name": "Fetch Metadata Fields1",
      "alwaysOutputData": true,
      "credentials": {
        "supabaseApi": {
          "id": "JXvQLWfqIjdcMyqm",
          "name": "Supabase B5rman"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Get input items\nconst items = $input.all();\n\n// Initialize output string\nlet output = '';\n\n// Loop through each input item\nfor (const item of items) {\n  const data = item.json;\n\n  const key = data.metadata_name;\n  const values = data.allowed_values;\n\n  output += `## ${key}\\n`;\n  output += `The filter key ${key} can have the following possible values\\n\\n`;\n  output += `${values.trim()}\\n\\n`;\n}\n\n// Take the first item and modify it with aggregated data\nconst firstItem = items[0];\nfirstItem.json.filterPromptInstructions = output.trim();\n\n// Return only the first item (now containing aggregated data)\nreturn [firstItem];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        15952,
        8416
      ],
      "id": "1dd07615-b134-4b43-b0fc-b3cc95e7aa79",
      "name": "Prep1"
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $('When Executed by Another Workflow').item.json.session_id }}"
      },
      "type": "@n8n/n8n-nodes-langchain.memoryPostgresChat",
      "typeVersion": 1.3,
      "position": [
        15248,
        8576
      ],
      "id": "cf905bbb-aace-48a9-9200-437fbe532e8b",
      "name": "Supabase Short-Term Memory1",
      "credentials": {
        "postgres": {
          "id": "tRlTzpjOmrCVSNLF",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "content": "## TODO\n### Add LightRAG Server URL",
        "height": 252,
        "width": 280
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        15520,
        8928
      ],
      "id": "76c8d018-bcac-4196-acfe-4a260620396d",
      "name": "Sticky Note19",
      "disabled": true
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "a4697977-31b6-4740-ae7c-0e3a35ecfdf0",
              "leftValue": "={{ $json }}",
              "rightValue": "",
              "operator": {
                "type": "object",
                "operation": "notEmpty",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        15728,
        8528
      ],
      "id": "29e949e5-4eea-4e92-8a9d-727f39181b4d",
      "name": "If"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://mgistrmwhxccyuchokbh.supabase.co/functions/v1/dynamic-hybrid-search",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n        \"query_text\": \"{{ $('When Executed by Another Workflow').item.json.query }}\",\n        \"query_embedding\": [{{ $json.data[0].embedding }}],\n        \"match_count\": 30,\n        \"filter\": {{ $('Prep Metadata1').isExecuted ? JSON.stringify($('Prep Metadata1').item.json.output.filter) : \"[]\" }},\n\"dense_weight\": {{ $('When Executed by Another Workflow').item.json.dense_weight }},\n\"sparse_weight\": {{ $('When Executed by Another Workflow').item.json.sparse_weight }},\n\"ilike_weight\": {{ $('When Executed by Another Workflow').item.json.ilike_weight }},\n\"fuzzy_weight\": {{ $('When Executed by Another Workflow').item.json.fuzzy_weight }},\n\"fuzzy_threshold\": {{ $('When Executed by Another Workflow').item.json.fuzzy_threshold }}\n      }",
        "options": {
          "redirect": {
            "redirect": {}
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        16864,
        8448
      ],
      "id": "291dfd44-7bc3-48bd-88b0-5dece189576f",
      "name": "Trigger Dynamic Hybrid Search",
      "alwaysOutputData": true,
      "credentials": {
        "supabaseApi": {
          "id": "JXvQLWfqIjdcMyqm",
          "name": "Supabase B5rman"
        }
      }
    },
    {
      "parameters": {
        "content": "## TODO\n### Add Edge Function URL\nYou can also change number of results returned",
        "height": 332,
        "width": 232
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        16800,
        8304
      ],
      "id": "a8b38973-571c-4440-bdba-9c6faa6d7a9e",
      "name": "Sticky Note22"
    },
    {
      "parameters": {
        "content": "## TODO (Optional)\nYou can change the number of results returned",
        "height": 300,
        "width": 232
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        17616,
        8320
      ],
      "id": "3474cd3a-d2f2-4296-90b2-0285a20c6340",
      "name": "Sticky Note23"
    },
    {
      "parameters": {
        "content": "",
        "height": 648,
        "width": 840,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        13696,
        8272
      ],
      "id": "19310bde-bc89-4d06-8115-6d72bfca4fe0",
      "name": "Sticky Note24"
    },
    {
      "parameters": {
        "content": "## v2.3.3\nThis it the retrieval sub-workflow for both our SOTA RAG System and RAG At Scale System\n\nSOTA RAG Setup instructions here:\nhttps://community.theaiautomators.com/c/automation-templates/state-of-the-art-n8n-rag-agent\n\nRAG at Scale Setup instructions here:\nhttps://community.theaiautomators.com/c/automation-templates/rag-at-scale-system",
        "height": 244,
        "width": 580,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        13856,
        8640
      ],
      "id": "a6f7efc1-a21e-44aa-aede-896a453a34f2",
      "name": "Sticky Note28"
    },
    {
      "parameters": {
        "content": "## TODO\n### Connect the Chat Trigger to your Agent of Choice",
        "height": 256,
        "width": 576
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        13856,
        8352
      ],
      "id": "853e794a-438e-4695-848c-8b423b00542c",
      "name": "Sticky Note30"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-5.2-2025-12-11",
          "mode": "list",
          "cachedResultName": "gpt-5.2-2025-12-11"
        },
        "builtInTools": {},
        "options": {
          "temperature": 0.1
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.3,
      "position": [
        14784,
        7968
      ],
      "id": "83c65cde-0cf6-4abd-aa26-b4b7f1823564",
      "name": "OpenAI Chat Model",
      "credentials": {
        "openAiApi": {
          "id": "r6dwaEmQxKEvrskM",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "description": "=Call this tool to query data from our knowledgebase using hybrid search (vector, lexical, ilike and fuzzy)\n\nYou can set different weights of this hybrid search depending on the type of query.\n\ndense_weight float DEFAULT 0.5,\nsparse_weight float DEFAULT 0.5,\nilike_weight float DEFAULT 0\nfuzzy_weight float DEFAULT 0\nfuzzy_threshold float DEFAULT 0.8\n\nFor semantic natural lanauge queries you can prioritise dense embeddings, \nFor technical terms and more traditional search you can priorize sparse lexical search\nFor exact matches for codes and IDs you can prioritze ilike wildcard matching\nFor typos that aren't picked up by semantic search, you can prioritize fuzzy matching\n\nIf looking for matches via ilike or fuzzy matches, the query should be extremely focused and short, as otherwise it will likely return zero results. (e.g. exact ID or code)\n\nAs pattern matching and fuzzy matching can add latency, I recommend defaulting this to zero unless you want to actually use it.\n\nTotal of the 4 weights much equal 1\n\nFuzzy Threshold adds significant latency should should be as high as possible - Default to 0.8",
        "workflowId": {
          "__rl": true,
          "value": "R_I-MybamT9nBjj0P-Gg3",
          "mode": "list",
          "cachedResultUrl": "/workflow/R_I-MybamT9nBjj0P-Gg3",
          "cachedResultName": "Retrieval Sub-Workflow v0.1.7"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "query": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('query', ``, 'string') }}",
            "session_id": "={{ $json.sessionId }}",
            "sparse_weight": "={{ $fromAI('sparse_weight', ``, 'number', 0.5) }}",
            "dense_weight": "={{ $fromAI('dense_weight', ``, 'number', 0.5) }}",
            "fuzzy_threshold": "={{ $fromAI('fuzzy_threshold', `this is the word similarity threshold in postgres - lower means more candidates however the call may time out`, 'number', 0.8) }}",
            "fuzzy_weight": "={{ $fromAI('fuzzy_weight', ``, 'number', 0) }}",
            "ilike_weight": "={{ $fromAI('ilike_weight', ``, 'number', 0) }}",
            "type": "hybrid"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "query",
              "displayName": "query",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "type",
              "displayName": "type",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "session_id",
              "displayName": "session_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "dense_weight",
              "displayName": "dense_weight",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            },
            {
              "id": "sparse_weight",
              "displayName": "sparse_weight",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            },
            {
              "id": "ilike_weight",
              "displayName": "ilike_weight",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            },
            {
              "id": "fuzzy_weight",
              "displayName": "fuzzy_weight",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            },
            {
              "id": "fuzzy_threshold",
              "displayName": "fuzzy_threshold",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        }
      },
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "typeVersion": 2.2,
      "position": [
        15136,
        7952
      ],
      "id": "532aa8d8-f0fc-4274-9080-118c4dbd56f2",
      "name": "Dynamic Hybrid Search3"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "claude-sonnet-4-5-20250929",
          "mode": "list",
          "cachedResultName": "Claude Sonnet 4.5"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
      "typeVersion": 1.3,
      "position": [
        14672,
        7856
      ],
      "id": "219c9f4b-308f-490f-9b81-e7057383b461",
      "name": "Anthropic Chat Model",
      "credentials": {
        "anthropicApi": {
          "id": "UyAehXbUNQAWwZOs",
          "name": "Claude SEB"
        }
      }
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "claude-sonnet-4-5-20250929",
          "mode": "list",
          "cachedResultName": "Claude Sonnet 4.5"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
      "typeVersion": 1.3,
      "position": [
        16112,
        8656
      ],
      "id": "b2045592-2539-4d79-be83-be1d75358571",
      "name": "Anthropic Chat Model3",
      "credentials": {
        "anthropicApi": {
          "id": "UyAehXbUNQAWwZOs",
          "name": "Claude SEB"
        }
      }
    }
  ],
  "pinData": {
    "Trigger Dynamic Hybrid Search": [
      {
        "json": {
          "id": 2017,
          "content": "This chunk is from a foundational paper on Bitcoin's peer-to-peer electronic cash, specifically # Document (Part 12)\n\n. If two nodes broadcast different versions of the next block simultaneously, somenodes may receive one or the other first. In that case, they work on the first one they received,but save the other branch in case it becomes longer. The tie will be broken when the next proof-of-work is found and one branch becomes longer; the nodes that were working on the otherbranch will then switch to the longer one.3BlockPrev Hash NonceTx Tx ...BlockPrev Hash NonceTx Tx ...New transaction broadcasts do not necessarily need to reach all nodes. As long as they reachmany nodes, they will get into a block before long. Block broadcasts are also tolerant of droppedmessages. If a node does not receive a block, it will request it when it receives the next block andrealizes it missed one.6",
          "metadata": {
            "pages": [
              1
            ],
            "doc_id": "1QPUdDN71t-VWQoxNbhrBSHRCvyP8hN8x",
            "doc_name": "bitcoin.pdf",
            "childRange": [
              0,
              30
            ],
            "department": "Legal",
            "chunk_index": 11,
            "parentRange": null,
            "indexed_date": "2026-02-15T22:31:24.957Z",
            "document_date": "2008-10-31",
            "cascading_path": "Document",
            "content_length": 895,
            "document_summary": "This document presents Bitcoin's design as a peer-to-peer electronic cash system that enables direct online payments without relying on trusted third parties, using proof-of-work to solve double-spending.",
            "split_part_number": 12,
            "total_chunks_in_section": 31,
            "document_headline_description": "A foundational paper on Bitcoin's peer-to-peer electronic cash"
          },
          "dense_score": 0.243462956467712,
          "sparse_score": 0,
          "ilike_score": 0,
          "fuzzy_score": 0,
          "final_score": 0.00655737704918033
        }
      },
      {
        "json": {
          "id": 2020,
          "content": "This chunk is from a foundational paper on Bitcoin's peer-to-peer electronic cash, specifically # Document (Part 15)\n\n. To facilitate this without breaking the block's hash,transactions are hashed in a Merkle Tree [7][2][5], with only the root included in the block's hash.Old blocks can then be compacted by stubbing off branches of the tree. The interior hashes donot need to be stored.A block header with no transactions would be about 80 bytes. If we suppose blocks aregenerated every 10 minutes, 80 bytes * 6 * 24 * 365 = 4.2MB per year",
          "metadata": {
            "pages": [
              1
            ],
            "doc_id": "1QPUdDN71t-VWQoxNbhrBSHRCvyP8hN8x",
            "doc_name": "bitcoin.pdf",
            "childRange": [
              0,
              30
            ],
            "department": "Legal",
            "chunk_index": 14,
            "parentRange": null,
            "indexed_date": "2026-02-15T22:31:24.958Z",
            "document_date": "2008-10-31",
            "cascading_path": "Document",
            "content_length": 541,
            "document_summary": "This document presents Bitcoin's design as a peer-to-peer electronic cash system that enables direct online payments without relying on trusted third parties, using proof-of-work to solve double-spending.",
            "split_part_number": 15,
            "total_chunks_in_section": 31,
            "document_headline_description": "A foundational paper on Bitcoin's peer-to-peer electronic cash"
          },
          "dense_score": 0.238770485593651,
          "sparse_score": 0,
          "ilike_score": 0,
          "fuzzy_score": 0,
          "final_score": 0.00645161290322581
        }
      },
      {
        "json": {
          "id": 2016,
          "content": "This chunk is from a foundational paper on Bitcoin's peer-to-peer electronic cash, specifically # Document (Part 11)\n\n. If they're generated too fast, the difficulty increases.5. NetworkThe steps to run the network are as follows:1) New transactions are broadcast to all nodes.2) Each node collects new transactions into a block.3) Each node works on finding a difficult proof-of-work for its block.4) When a node finds a proof-of-work, it broadcasts the block to all nodes.5) Nodes accept the block only if all transactions in it are valid and not already spent.6) Nodes express their acceptance of the block by working on creating the next block in thechain, using the hash of the accepted block as the previous hash.Nodes always consider the longest chain to be the correct one and will keep working onextending it",
          "metadata": {
            "pages": [
              1
            ],
            "doc_id": "1QPUdDN71t-VWQoxNbhrBSHRCvyP8hN8x",
            "doc_name": "bitcoin.pdf",
            "childRange": [
              0,
              30
            ],
            "department": "Legal",
            "chunk_index": 10,
            "parentRange": null,
            "indexed_date": "2026-02-15T22:31:24.957Z",
            "document_date": "2008-10-31",
            "cascading_path": "Document",
            "content_length": 817,
            "document_summary": "This document presents Bitcoin's design as a peer-to-peer electronic cash system that enables direct online payments without relying on trusted third parties, using proof-of-work to solve double-spending.",
            "split_part_number": 11,
            "total_chunks_in_section": 31,
            "document_headline_description": "A foundational paper on Bitcoin's peer-to-peer electronic cash"
          },
          "dense_score": 0.237578064203264,
          "sparse_score": 0,
          "ilike_score": 0,
          "fuzzy_score": 0,
          "final_score": 0.00634920634920635
        }
      },
      {
        "json": {
          "id": 2034,
          "content": "This chunk is from a foundational paper on Bitcoin's peer-to-peer electronic cash, specifically # Document (Part 29)\n\n. To solve this, weproposed a peer-to-peer network using proof-of-work to record a public history of transactionsthat quickly becomes computationally impractical for an attacker to change if honest nodescontrol a majority of CPU power. The network is robust in its unstructured simplicity. Nodeswork all at once with little coordination. They do not need to be identified, since messages arenot routed to any particular place and only need to be delivered on a best effort basis. Nodes canleave and rejoin the network at will, accepting the proof-of-work chain as proof of whathappened while they were gone. They vote with their CPU power, expressing their acceptance ofvalid blocks by working on extending them and rejecting invalid blocks by refusing to work onthem",
          "metadata": {
            "pages": [
              1
            ],
            "doc_id": "1QPUdDN71t-VWQoxNbhrBSHRCvyP8hN8x",
            "doc_name": "bitcoin.pdf",
            "childRange": [
              0,
              30
            ],
            "department": "Legal",
            "chunk_index": 28,
            "parentRange": null,
            "indexed_date": "2026-02-15T22:31:24.958Z",
            "document_date": "2008-10-31",
            "cascading_path": "Document",
            "content_length": 885,
            "document_summary": "This document presents Bitcoin's design as a peer-to-peer electronic cash system that enables direct online payments without relying on trusted third parties, using proof-of-work to solve double-spending.",
            "split_part_number": 29,
            "total_chunks_in_section": 31,
            "document_headline_description": "A foundational paper on Bitcoin's peer-to-peer electronic cash"
          },
          "dense_score": 0.231006293356794,
          "sparse_score": 0,
          "ilike_score": 0,
          "fuzzy_score": 0,
          "final_score": 0.00625
        }
      },
      {
        "json": {
          "id": 2026,
          "content": "This chunk is from a foundational paper on Bitcoin's peer-to-peer electronic cash, specifically # Document (Part 21)\n\n. Some linking is still unavoidable with multi-inputtransactions, which necessarily reveal that their inputs were owned by the same owner. The riskis that if the owner of a key is revealed, linking could reveal other transactions that belonged tothe same owner.11. CalculationsWe consider the scenario of an attacker trying to generate an alternate chain faster than the honestchain. Even if this is accomplished, it does not throw the system open to arbitrary changes, suchas creating value out of thin air or taking money that never belonged to the attacker. Nodes arenot going to accept an invalid transaction as payment, and honest nodes will never accept a blockcontaining them",
          "metadata": {
            "pages": [
              1
            ],
            "doc_id": "1QPUdDN71t-VWQoxNbhrBSHRCvyP8hN8x",
            "doc_name": "bitcoin.pdf",
            "childRange": [
              0,
              30
            ],
            "department": "Legal",
            "chunk_index": 20,
            "parentRange": null,
            "indexed_date": "2026-02-15T22:31:24.958Z",
            "document_date": "2008-10-31",
            "cascading_path": "Document",
            "content_length": 800,
            "document_summary": "This document presents Bitcoin's design as a peer-to-peer electronic cash system that enables direct online payments without relying on trusted third parties, using proof-of-work to solve double-spending.",
            "split_part_number": 21,
            "total_chunks_in_section": 31,
            "document_headline_description": "A foundational paper on Bitcoin's peer-to-peer electronic cash"
          },
          "dense_score": 0.230620059798373,
          "sparse_score": 0,
          "ilike_score": 0,
          "fuzzy_score": 0,
          "final_score": 0.00615384615384615
        }
      },
      {
        "json": {
          "id": 2023,
          "content": "This chunk is from a foundational paper on Bitcoin's peer-to-peer electronic cash, specifically # Document (Part 18)\n\n. While network nodes can verifytransactions for themselves, the simplified method can be fooled by an attacker's fabricatedtransactions for as long as the attacker can continue to overpower the network. One strategy toprotect against this would be to accept alerts from network nodes when they detect an invalidblock, prompting the user's software to download the full block and alerted transactions toconfirm the inconsistency. Businesses that receive frequent payments will probably still want torun their own nodes for more independent security and quicker verification.9. Combining and Splitting ValueAlthough it would be possible to handle coins individually, it would be unwieldy to make aseparate transaction for every cent in a transfer",
          "metadata": {
            "pages": [
              1
            ],
            "doc_id": "1QPUdDN71t-VWQoxNbhrBSHRCvyP8hN8x",
            "doc_name": "bitcoin.pdf",
            "childRange": [
              0,
              30
            ],
            "department": "Legal",
            "chunk_index": 17,
            "parentRange": null,
            "indexed_date": "2026-02-15T22:31:24.958Z",
            "document_date": "2008-10-31",
            "cascading_path": "Document",
            "content_length": 863,
            "document_summary": "This document presents Bitcoin's design as a peer-to-peer electronic cash system that enables direct online payments without relying on trusted third parties, using proof-of-work to solve double-spending.",
            "split_part_number": 18,
            "total_chunks_in_section": 31,
            "document_headline_description": "A foundational paper on Bitcoin's peer-to-peer electronic cash"
          },
          "dense_score": 0.205391906727817,
          "sparse_score": 0,
          "ilike_score": 0,
          "fuzzy_score": 0,
          "final_score": 0.00606060606060606
        }
      },
      {
        "json": {
          "id": 2021,
          "content": "This chunk is from a foundational paper on Bitcoin's peer-to-peer electronic cash, specifically # Document (Part 16)\n\n. With computer systemstypically selling with 2GB of RAM as of 2008, and Moore's Law predicting current growth of1.2GB per year, storage should not be a problem even if the block headers must be kept inmemory.4BlockBlock Block Header (Block Hash)Prev Hash NonceHash01Hash0 Hash1 Hash2 Hash3Hash23Root HashHash01Hash2Tx3Hash23Block Header (Block Hash)Root HashTransactions Hashed in a Merkle Tree After Pruning Tx0-2 from the BlockPrev Hash NonceHash3Tx0 Tx1 Tx2 Tx38. Simplified Payment VerificationIt is possible to verify payments without running a full network node",
          "metadata": {
            "pages": [
              1
            ],
            "doc_id": "1QPUdDN71t-VWQoxNbhrBSHRCvyP8hN8x",
            "doc_name": "bitcoin.pdf",
            "childRange": [
              0,
              30
            ],
            "department": "Legal",
            "chunk_index": 15,
            "parentRange": null,
            "indexed_date": "2026-02-15T22:31:24.958Z",
            "document_date": "2008-10-31",
            "cascading_path": "Document",
            "content_length": 686,
            "document_summary": "This document presents Bitcoin's design as a peer-to-peer electronic cash system that enables direct online payments without relying on trusted third parties, using proof-of-work to solve double-spending.",
            "split_part_number": 16,
            "total_chunks_in_section": 31,
            "document_headline_description": "A foundational paper on Bitcoin's peer-to-peer electronic cash"
          },
          "dense_score": 0.198880785570238,
          "sparse_score": 0,
          "ilike_score": 0,
          "fuzzy_score": 0,
          "final_score": 0.00597014925373134
        }
      },
      {
        "json": {
          "id": 2022,
          "content": "This chunk is from a foundational paper on Bitcoin's peer-to-peer electronic cash, specifically # Document (Part 17)\n\n. A user only needs to keepa copy of the block headers of the longest proof-of-work chain, which he can get by queryingnetwork nodes until he's convinced he has the longest chain, and obtain the Merkle branchlinking the transaction to the block it's timestamped in. He can't check the transaction forhimself, but by linking it to a place in the chain, he can see that a network node has accepted it,and blocks added after it further confirm the network has accepted it.As such, the verification is reliable as long as honest nodes control the network, but is morevulnerable if the network is overpowered by an attacker",
          "metadata": {
            "pages": [
              1
            ],
            "doc_id": "1QPUdDN71t-VWQoxNbhrBSHRCvyP8hN8x",
            "doc_name": "bitcoin.pdf",
            "childRange": [
              0,
              30
            ],
            "department": "Legal",
            "chunk_index": 16,
            "parentRange": null,
            "indexed_date": "2026-02-15T22:31:24.958Z",
            "document_date": "2008-10-31",
            "cascading_path": "Document",
            "content_length": 736,
            "document_summary": "This document presents Bitcoin's design as a peer-to-peer electronic cash system that enables direct online payments without relying on trusted third parties, using proof-of-work to solve double-spending.",
            "split_part_number": 17,
            "total_chunks_in_section": 31,
            "document_headline_description": "A foundational paper on Bitcoin's peer-to-peer electronic cash"
          },
          "dense_score": 0.193930413957263,
          "sparse_score": 0,
          "ilike_score": 0,
          "fuzzy_score": 0,
          "final_score": 0.00588235294117647
        }
      },
      {
        "json": {
          "id": 2024,
          "content": "This chunk is from a foundational paper on Bitcoin's peer-to-peer electronic cash, specifically # Document (Part 19)\n\n. To allow value to be split and combined,transactions contain multiple inputs and outputs. Normally there will be either a single inputfrom a larger previous transaction or multiple inputs combining smaller amounts, and at most twooutputs: one for the payment, and one returning the change, if any, back to the sender.It should be noted that fan-out, where a transaction depends on several transactions, and thosetransactions depend on many more, is not a problem here. There is never the need to extract acomplete standalone copy of a transaction's history.5TransactionIn...In Out...Hash01Hash2 Hash3Hash23Block HeaderMerkle RootPrev Hash NonceBlock HeaderMerkle RootPrev Hash NonceBlock HeaderMerkle RootPrev Hash NonceMerkle Branch for Tx3Longest Proof-of-Work ChainTx310",
          "metadata": {
            "pages": [
              1
            ],
            "doc_id": "1QPUdDN71t-VWQoxNbhrBSHRCvyP8hN8x",
            "doc_name": "bitcoin.pdf",
            "childRange": [
              0,
              30
            ],
            "department": "Legal",
            "chunk_index": 18,
            "parentRange": null,
            "indexed_date": "2026-02-15T22:31:24.958Z",
            "document_date": "2008-10-31",
            "cascading_path": "Document",
            "content_length": 893,
            "document_summary": "This document presents Bitcoin's design as a peer-to-peer electronic cash system that enables direct online payments without relying on trusted third parties, using proof-of-work to solve double-spending.",
            "split_part_number": 19,
            "total_chunks_in_section": 31,
            "document_headline_description": "A foundational paper on Bitcoin's peer-to-peer electronic cash"
          },
          "dense_score": 0.192312650956231,
          "sparse_score": 0,
          "ilike_score": 0,
          "fuzzy_score": 0,
          "final_score": 0.00579710144927536
        }
      },
      {
        "json": {
          "id": 2018,
          "content": "This chunk is from a foundational paper on Bitcoin's peer-to-peer electronic cash, specifically # Document (Part 13)\n\n. IncentiveBy convention, the first transaction in a block is a special transaction that starts a new coin ownedby the creator of the block. This adds an incentive for nodes to support the network, and providesa way to initially distribute coins into circulation, since there is no central authority to issue them.The steady addition of a constant of amount of new coins is analogous to gold miners expendingresources to add gold to circulation. In our case, it is CPU time and electricity that is expended.The incentive can also be funded with transaction fees. If the output value of a transaction isless than its input value, the difference is a transaction fee that is added to the incentive value ofthe block containing the transaction",
          "metadata": {
            "pages": [
              1
            ],
            "doc_id": "1QPUdDN71t-VWQoxNbhrBSHRCvyP8hN8x",
            "doc_name": "bitcoin.pdf",
            "childRange": [
              0,
              30
            ],
            "department": "Legal",
            "chunk_index": 12,
            "parentRange": null,
            "indexed_date": "2026-02-15T22:31:24.958Z",
            "document_date": "2008-10-31",
            "cascading_path": "Document",
            "content_length": 858,
            "document_summary": "This document presents Bitcoin's design as a peer-to-peer electronic cash system that enables direct online payments without relying on trusted third parties, using proof-of-work to solve double-spending.",
            "split_part_number": 13,
            "total_chunks_in_section": 31,
            "document_headline_description": "A foundational paper on Bitcoin's peer-to-peer electronic cash"
          },
          "dense_score": 0.183450113740571,
          "sparse_score": 0,
          "ilike_score": 0,
          "fuzzy_score": 0,
          "final_score": 0.00571428571428571
        }
      },
      {
        "json": {
          "id": 2010,
          "content": "This chunk is from a foundational paper on Bitcoin's peer-to-peer electronic cash, specifically # Document (Part 5)\n\n. Thesystem is secure as long as honest nodes collectively control more CPU power than anycooperating group of attacker nodes.12. TransactionsWe define an electronic coin as a chain of digital signatures. Each owner transfers the coin to thenext by digitally signing a hash of the previous transaction and the public key of the next ownerand adding these to the end of the coin. A payee can verify the signatures to verify the chain ofownership.The problem of course is the payee can't verify that one of the owners did not double-spendthe coin. A common solution is to introduce a trusted central authority, or mint, that checks everytransaction for double spending",
          "metadata": {
            "pages": [
              1
            ],
            "doc_id": "1QPUdDN71t-VWQoxNbhrBSHRCvyP8hN8x",
            "doc_name": "bitcoin.pdf",
            "childRange": [
              0,
              30
            ],
            "department": "Legal",
            "chunk_index": 4,
            "parentRange": null,
            "indexed_date": "2026-02-15T22:31:24.957Z",
            "document_date": "2008-10-31",
            "cascading_path": "Document",
            "content_length": 783,
            "document_summary": "This document presents Bitcoin's design as a peer-to-peer electronic cash system that enables direct online payments without relying on trusted third parties, using proof-of-work to solve double-spending.",
            "split_part_number": 5,
            "total_chunks_in_section": 31,
            "document_headline_description": "A foundational paper on Bitcoin's peer-to-peer electronic cash"
          },
          "dense_score": 0.17929144203663,
          "sparse_score": 0,
          "ilike_score": 0,
          "fuzzy_score": 0,
          "final_score": 0.00563380281690141
        }
      },
      {
        "json": {
          "id": 2014,
          "content": "This chunk is from a foundational paper on Bitcoin's peer-to-peer electronic cash, specifically # Document (Part 9)\n\n. The average work required is exponential in the numberof zero bits required and can be verified by executing a single hash.For our timestamp network, we implement the proof-of-work by incrementing a nonce in theblock until a value is found that gives the block's hash the required zero bits. Once the CPUeffort has been expended to make it satisfy the proof-of-work, the block cannot be changedwithout redoing the work. As later blocks are chained after it, the work to change the blockwould include redoing all the blocks after it.The proof-of-work also solves the problem of determining representation in majority decisionmaking. If the majority were based on one-IP-address-one-vote, it could be subverted by anyoneable to allocate many IPs. Proof-of-work is essentially one-CPU-one-vote",
          "metadata": {
            "pages": [
              1
            ],
            "doc_id": "1QPUdDN71t-VWQoxNbhrBSHRCvyP8hN8x",
            "doc_name": "bitcoin.pdf",
            "childRange": [
              0,
              30
            ],
            "department": "Legal",
            "chunk_index": 8,
            "parentRange": null,
            "indexed_date": "2026-02-15T22:31:24.957Z",
            "document_date": "2008-10-31",
            "cascading_path": "Document",
            "content_length": 909,
            "document_summary": "This document presents Bitcoin's design as a peer-to-peer electronic cash system that enables direct online payments without relying on trusted third parties, using proof-of-work to solve double-spending.",
            "split_part_number": 9,
            "total_chunks_in_section": 31,
            "document_headline_description": "A foundational paper on Bitcoin's peer-to-peer electronic cash"
          },
          "dense_score": 0.169843594422555,
          "sparse_score": 0,
          "ilike_score": 0,
          "fuzzy_score": 0,
          "final_score": 0.00555555555555556
        }
      },
      {
        "json": {
          "id": 2013,
          "content": "This chunk is from a foundational paper on Bitcoin's peer-to-peer electronic cash, specifically # Document (Part 8)\n\n. Each timestamp includes the previous timestamp inits hash, forming a chain, with each additional timestamp reinforcing the ones before it.2BlockItem Item ...HashBlockItem Item ...HashTransactionOwner 1'sPublic KeyOwner 0'sSignatureHashTransactionOwner 2'sPublic KeyOwner 1'sSignatureHashVerifyTransactionOwner 3'sPublic KeyOwner 2'sSignatureHashVerifyOwner 2'sPrivate KeyOwner 1'sPrivate KeySignSignOwner 3'sPrivate Key4. Proof-of-WorkTo implement a distributed timestamp server on a peer-to-peer basis, we will need to use a proof-of-work system similar to Adam Back's Hashcash [6], rather than newspaper or Usenet posts.The proof-of-work involves scanning for a value that when hashed, such as with SHA-256, thehash begins with a number of zero bits",
          "metadata": {
            "pages": [
              1
            ],
            "doc_id": "1QPUdDN71t-VWQoxNbhrBSHRCvyP8hN8x",
            "doc_name": "bitcoin.pdf",
            "childRange": [
              0,
              30
            ],
            "department": "Legal",
            "chunk_index": 7,
            "parentRange": null,
            "indexed_date": "2026-02-15T22:31:24.957Z",
            "document_date": "2008-10-31",
            "cascading_path": "Document",
            "content_length": 870,
            "document_summary": "This document presents Bitcoin's design as a peer-to-peer electronic cash system that enables direct online payments without relying on trusted third parties, using proof-of-work to solve double-spending.",
            "split_part_number": 8,
            "total_chunks_in_section": 31,
            "document_headline_description": "A foundational paper on Bitcoin's peer-to-peer electronic cash"
          },
          "dense_score": 0.169065932575818,
          "sparse_score": 0,
          "ilike_score": 0,
          "fuzzy_score": 0,
          "final_score": 0.00547945205479452
        }
      },
      {
        "json": {
          "id": 2006,
          "content": "This chunk is from a foundational paper on Bitcoin's peer-to-peer electronic cash, specifically # Document (Part 1)\n\nBitcoin: A Peer-to-Peer Electronic Cash SystemSatoshi Nakamotosatoshin@gmx.comwww.bitcoin.orgAbstract. A purely peer-to-peer version of electronic cash would allow onlinepayments to be sent directly from one party to another without going through afinancial institution. Digital signatures provide part of the solution, but the mainbenefits are lost if a trusted third party is still required to prevent double-spending.We propose a solution to the double-spending problem using a peer-to-peer network.The network timestamps transactions by hashing them into an ongoing chain ofhash-based proof-of-work, forming a record that cannot be changed without redoingthe proof-of-work",
          "metadata": {
            "pages": [
              1
            ],
            "doc_id": "1QPUdDN71t-VWQoxNbhrBSHRCvyP8hN8x",
            "doc_name": "bitcoin.pdf",
            "childRange": [
              0,
              30
            ],
            "department": "Legal",
            "chunk_index": 0,
            "parentRange": null,
            "indexed_date": "2026-02-15T22:31:24.957Z",
            "document_date": "2008-10-31",
            "cascading_path": "Document",
            "content_length": 793,
            "document_summary": "This document presents Bitcoin's design as a peer-to-peer electronic cash system that enables direct online payments without relying on trusted third parties, using proof-of-work to solve double-spending.",
            "split_part_number": 1,
            "total_chunks_in_section": 31,
            "document_headline_description": "A foundational paper on Bitcoin's peer-to-peer electronic cash"
          },
          "dense_score": 0.167980740546033,
          "sparse_score": 0,
          "ilike_score": 0,
          "fuzzy_score": 0,
          "final_score": 0.00540540540540541
        }
      },
      {
        "json": {
          "id": 2030,
          "content": "This chunk is from a foundational paper on Bitcoin's peer-to-peer electronic cash, specifically # Document (Part 25)\n\n. This prevents the sender from preparing a chain of blocks ahead of time by working onit continuously until he is lucky enough to get far enough ahead, then executing the transaction atthat moment. Once the transaction is sent, the dishonest sender starts working in secret on aparallel chain containing an alternate version of his transaction.The recipient waits until the transaction has been added to a block and z blocks have beenlinked after it",
          "metadata": {
            "pages": [
              1
            ],
            "doc_id": "1QPUdDN71t-VWQoxNbhrBSHRCvyP8hN8x",
            "doc_name": "bitcoin.pdf",
            "childRange": [
              0,
              30
            ],
            "department": "Legal",
            "chunk_index": 24,
            "parentRange": null,
            "indexed_date": "2026-02-15T22:31:24.958Z",
            "document_date": "2008-10-31",
            "cascading_path": "Document",
            "content_length": 568,
            "document_summary": "This document presents Bitcoin's design as a peer-to-peer electronic cash system that enables direct online payments without relying on trusted third parties, using proof-of-work to solve double-spending.",
            "split_part_number": 25,
            "total_chunks_in_section": 31,
            "document_headline_description": "A foundational paper on Bitcoin's peer-to-peer electronic cash"
          },
          "dense_score": 0.158969430739182,
          "sparse_score": 0,
          "ilike_score": 0,
          "fuzzy_score": 0,
          "final_score": 0.00533333333333333
        }
      },
      {
        "json": {
          "id": 2012,
          "content": "This chunk is from a foundational paper on Bitcoin's peer-to-peer electronic cash, specifically # Document (Part 7)\n\n. To accomplish this without a trusted party, transactions must bepublicly announced [1], and we need a system for participants to agree on a single history of theorder in which they were received. The payee needs proof that at the time of each transaction, themajority of nodes agreed it was the first received.3. Timestamp ServerThe solution we propose begins with a timestamp server. A timestamp server works by taking ahash of a block of items to be timestamped and widely publishing the hash, such as in anewspaper or Usenet post [2-5]. The timestamp proves that the data must have existed at thetime, obviously, in order to get into the hash",
          "metadata": {
            "pages": [
              1
            ],
            "doc_id": "1QPUdDN71t-VWQoxNbhrBSHRCvyP8hN8x",
            "doc_name": "bitcoin.pdf",
            "childRange": [
              0,
              30
            ],
            "department": "Legal",
            "chunk_index": 6,
            "parentRange": null,
            "indexed_date": "2026-02-15T22:31:24.957Z",
            "document_date": "2008-10-31",
            "cascading_path": "Document",
            "content_length": 764,
            "document_summary": "This document presents Bitcoin's design as a peer-to-peer electronic cash system that enables direct online payments without relying on trusted third parties, using proof-of-work to solve double-spending.",
            "split_part_number": 7,
            "total_chunks_in_section": 31,
            "document_headline_description": "A foundational paper on Bitcoin's peer-to-peer electronic cash"
          },
          "dense_score": 0.158670942941796,
          "sparse_score": 0,
          "ilike_score": 0,
          "fuzzy_score": 0,
          "final_score": 0.00526315789473684
        }
      },
      {
        "json": {
          "id": 2015,
          "content": "This chunk is from a foundational paper on Bitcoin's peer-to-peer electronic cash, specifically # Document (Part 10)\n\n. The majoritydecision is represented by the longest chain, which has the greatest proof-of-work effort investedin it. If a majority of CPU power is controlled by honest nodes, the honest chain will grow thefastest and outpace any competing chains. To modify a past block, an attacker would have toredo the proof-of-work of the block and all blocks after it and then catch up with and surpass thework of the honest nodes. We will show later that the probability of a slower attacker catching updiminishes exponentially as subsequent blocks are added.To compensate for increasing hardware speed and varying interest in running nodes over time,the proof-of-work difficulty is determined by a moving average targeting an average number ofblocks per hour",
          "metadata": {
            "pages": [
              1
            ],
            "doc_id": "1QPUdDN71t-VWQoxNbhrBSHRCvyP8hN8x",
            "doc_name": "bitcoin.pdf",
            "childRange": [
              0,
              30
            ],
            "department": "Legal",
            "chunk_index": 9,
            "parentRange": null,
            "indexed_date": "2026-02-15T22:31:24.957Z",
            "document_date": "2008-10-31",
            "cascading_path": "Document",
            "content_length": 868,
            "document_summary": "This document presents Bitcoin's design as a peer-to-peer electronic cash system that enables direct online payments without relying on trusted third parties, using proof-of-work to solve double-spending.",
            "split_part_number": 10,
            "total_chunks_in_section": 31,
            "document_headline_description": "A foundational paper on Bitcoin's peer-to-peer electronic cash"
          },
          "dense_score": 0.155856540450066,
          "sparse_score": 0,
          "ilike_score": 0,
          "fuzzy_score": 0,
          "final_score": 0.00519480519480519
        }
      },
      {
        "json": {
          "id": 2033,
          "content": "This chunk is from a foundational paper on Bitcoin's peer-to-peer electronic cash, specifically # Document (Part 28)\n\n. This prevents the sender from preparing a chain of blocks ahead of time by working onit continuously until he is lucky enough to get far enough ahead, then executing the transaction atthat moment. Once the transaction is sent, the dishonest sender starts working in secret on aparallel chain containing an alternate version of his transaction.The recipient waits until the transaction has been added to a block and z blocks have beenlinked after it. ConclusionWe have proposed a system for electronic transactions without relying on trust. We started withthe usual framework of coins made from digital signatures, which provides strong control ofownership, but is incomplete without a way to prevent double-spending",
          "metadata": {
            "pages": [
              1
            ],
            "doc_id": "1QPUdDN71t-VWQoxNbhrBSHRCvyP8hN8x",
            "doc_name": "bitcoin.pdf",
            "childRange": [
              0,
              30
            ],
            "department": "Legal",
            "chunk_index": 27,
            "parentRange": null,
            "indexed_date": "2026-02-15T22:31:24.958Z",
            "document_date": "2008-10-31",
            "cascading_path": "Document",
            "content_length": 835,
            "document_summary": "This document presents Bitcoin's design as a peer-to-peer electronic cash system that enables direct online payments without relying on trusted third parties, using proof-of-work to solve double-spending.",
            "split_part_number": 28,
            "total_chunks_in_section": 31,
            "document_headline_description": "A foundational paper on Bitcoin's peer-to-peer electronic cash"
          },
          "dense_score": 0.153302123945827,
          "sparse_score": 0,
          "ilike_score": 0,
          "fuzzy_score": 0,
          "final_score": 0.00512820512820513
        }
      },
      {
        "json": {
          "id": 2036,
          "content": "This chunk is from a foundational paper on Bitcoin's peer-to-peer electronic cash, specifically # Document (Part 31)\n\n. Stornetta, \"Secure names for bit-strings,\" In Proceedings of the 4th ACM Conferenceon Computer and Communications Security, pages 28-35, April 1997.[6] A. Back, \"Hashcash - a denial of service counter-measure,\"http://www.hashcash.org/papers/hashcash.pdf, 2002.[7] R.C. Merkle, \"Protocols for public key cryptosystems,\" In Proc. 1980 Symposium on Security andPrivacy, IEEE Computer Society, pages 122-133, April 1980.[8] W. Feller, \"An introduction to probability theory and its applications,\" 1957.9",
          "metadata": {
            "pages": [
              1
            ],
            "doc_id": "1QPUdDN71t-VWQoxNbhrBSHRCvyP8hN8x",
            "doc_name": "bitcoin.pdf",
            "childRange": [
              0,
              30
            ],
            "department": "Legal",
            "chunk_index": 30,
            "parentRange": null,
            "indexed_date": "2026-02-15T22:31:24.958Z",
            "document_date": "2008-10-31",
            "cascading_path": "Document",
            "content_length": 619,
            "document_summary": "This document presents Bitcoin's design as a peer-to-peer electronic cash system that enables direct online payments without relying on trusted third parties, using proof-of-work to solve double-spending.",
            "split_part_number": 31,
            "total_chunks_in_section": 31,
            "document_headline_description": "A foundational paper on Bitcoin's peer-to-peer electronic cash"
          },
          "dense_score": 0.152660949766125,
          "sparse_score": 0,
          "ilike_score": 0,
          "fuzzy_score": 0,
          "final_score": 0.00506329113924051
        }
      },
      {
        "json": {
          "id": 2019,
          "content": "This chunk is from a foundational paper on Bitcoin's peer-to-peer electronic cash, specifically # Document (Part 14)\n\n. Once a predetermined number of coins have enteredcirculation, the incentive can transition entirely to transaction fees and be completely inflationfree.The incentive may help encourage nodes to stay honest. If a greedy attacker is able toassemble more CPU power than all the honest nodes, he would have to choose between using itto defraud people by stealing back his payments, or using it to generate new coins. He ought tofind it more profitable to play by the rules, such rules that favour him with more new coins thaneveryone else combined, than to undermine the system and the validity of his own wealth.7. Reclaiming Disk SpaceOnce the latest transaction in a coin is buried under enough blocks, the spent transactions beforeit can be discarded to save disk space",
          "metadata": {
            "pages": [
              1
            ],
            "doc_id": "1QPUdDN71t-VWQoxNbhrBSHRCvyP8hN8x",
            "doc_name": "bitcoin.pdf",
            "childRange": [
              0,
              30
            ],
            "department": "Legal",
            "chunk_index": 13,
            "parentRange": null,
            "indexed_date": "2026-02-15T22:31:24.958Z",
            "document_date": "2008-10-31",
            "cascading_path": "Document",
            "content_length": 889,
            "document_summary": "This document presents Bitcoin's design as a peer-to-peer electronic cash system that enables direct online payments without relying on trusted third parties, using proof-of-work to solve double-spending.",
            "split_part_number": 14,
            "total_chunks_in_section": 31,
            "document_headline_description": "A foundational paper on Bitcoin's peer-to-peer electronic cash"
          },
          "dense_score": 0.150207452506938,
          "sparse_score": 0,
          "ilike_score": 0,
          "fuzzy_score": 0,
          "final_score": 0.005
        }
      },
      {
        "json": {
          "id": 2025,
          "content": "This chunk is from a foundational paper on Bitcoin's peer-to-peer electronic cash, specifically # Document (Part 20)\n\n. PrivacyThe traditional banking model achieves a level of privacy by limiting access to information to theparties involved and the trusted third party. The necessity to announce all transactions publiclyprecludes this method, but privacy can still be maintained by breaking the flow of information inanother place: by keeping public keys anonymous. The public can see that someone is sendingan amount to someone else, but without information linking the transaction to anyone. This issimilar to the level of information released by stock exchanges, where the time and size ofindividual trades, the \"tape\", is made public, but without telling who the parties were.As an additional firewall, a new key pair should be used for each transaction to keep themfrom being linked to a common owner",
          "metadata": {
            "pages": [
              1
            ],
            "doc_id": "1QPUdDN71t-VWQoxNbhrBSHRCvyP8hN8x",
            "doc_name": "bitcoin.pdf",
            "childRange": [
              0,
              30
            ],
            "department": "Legal",
            "chunk_index": 19,
            "parentRange": null,
            "indexed_date": "2026-02-15T22:31:24.958Z",
            "document_date": "2008-10-31",
            "cascading_path": "Document",
            "content_length": 907,
            "document_summary": "This document presents Bitcoin's design as a peer-to-peer electronic cash system that enables direct online payments without relying on trusted third parties, using proof-of-work to solve double-spending.",
            "split_part_number": 20,
            "total_chunks_in_section": 31,
            "document_headline_description": "A foundational paper on Bitcoin's peer-to-peer electronic cash"
          },
          "dense_score": 0.145946609490706,
          "sparse_score": 0,
          "ilike_score": 0,
          "fuzzy_score": 0,
          "final_score": 0.00493827160493827
        }
      },
      {
        "json": {
          "id": 2007,
          "content": "This chunk is from a foundational paper on Bitcoin's peer-to-peer electronic cash, specifically # Document (Part 2)\n\n. The longest chain not only serves as proof of the sequence ofevents witnessed, but proof that it came from the largest pool of CPU power. Aslong as a majority of CPU power is controlled by nodes that are not cooperating toattack the network, they'll generate the longest chain and outpace attackers. Thenetwork itself requires minimal structure. Messages are broadcast on a best effortbasis, and nodes can leave and rejoin the network at will, accepting the longestproof-of-work chain as proof of what happened while they were gone.1. IntroductionCommerce on the Internet has come to rely almost exclusively on financial institutions serving astrusted third parties to process electronic payments",
          "metadata": {
            "pages": [
              1
            ],
            "doc_id": "1QPUdDN71t-VWQoxNbhrBSHRCvyP8hN8x",
            "doc_name": "bitcoin.pdf",
            "childRange": [
              0,
              30
            ],
            "department": "Legal",
            "chunk_index": 1,
            "parentRange": null,
            "indexed_date": "2026-02-15T22:31:24.957Z",
            "document_date": "2008-10-31",
            "cascading_path": "Document",
            "content_length": 815,
            "document_summary": "This document presents Bitcoin's design as a peer-to-peer electronic cash system that enables direct online payments without relying on trusted third parties, using proof-of-work to solve double-spending.",
            "split_part_number": 2,
            "total_chunks_in_section": 31,
            "document_headline_description": "A foundational paper on Bitcoin's peer-to-peer electronic cash"
          },
          "dense_score": 0.143755274266633,
          "sparse_score": 0,
          "ilike_score": 0,
          "fuzzy_score": 0,
          "final_score": 0.0048780487804878
        }
      },
      {
        "json": {
          "id": 2027,
          "content": "This chunk is from a foundational paper on Bitcoin's peer-to-peer electronic cash, specifically # Document (Part 22)\n\n. An attacker can only try to change one of his own transactions to take backmoney he recently spent.The race between the honest chain and an attacker chain can be characterized as a BinomialRandom Walk. The success event is the honest chain being extended by one block, increasing itslead by +1, and the failure event is the attacker's chain being extended by one block, reducing thegap by -1.The probability of an attacker catching up from a given deficit is analogous to a Gambler'sRuin problem. Suppose a gambler with unlimited credit starts at a deficit and plays potentially aninfinite number of trials to try to reach breakeven",
          "metadata": {
            "pages": [
              1
            ],
            "doc_id": "1QPUdDN71t-VWQoxNbhrBSHRCvyP8hN8x",
            "doc_name": "bitcoin.pdf",
            "childRange": [
              0,
              30
            ],
            "department": "Legal",
            "chunk_index": 21,
            "parentRange": null,
            "indexed_date": "2026-02-15T22:31:24.958Z",
            "document_date": "2008-10-31",
            "cascading_path": "Document",
            "content_length": 752,
            "document_summary": "This document presents Bitcoin's design as a peer-to-peer electronic cash system that enables direct online payments without relying on trusted third parties, using proof-of-work to solve double-spending.",
            "split_part_number": 22,
            "total_chunks_in_section": 31,
            "document_headline_description": "A foundational paper on Bitcoin's peer-to-peer electronic cash"
          },
          "dense_score": 0.138097822666169,
          "sparse_score": 0,
          "ilike_score": 0,
          "fuzzy_score": 0,
          "final_score": 0.00481927710843374
        }
      },
      {
        "json": {
          "id": 2011,
          "content": "This chunk is from a foundational paper on Bitcoin's peer-to-peer electronic cash, specifically # Document (Part 6)\n\n. After each transaction, the coin must be returned to the mint toissue a new coin, and only coins issued directly from the mint are trusted not to be double-spent.The problem with this solution is that the fate of the entire money system depends on thecompany running the mint, with every transaction having to go through them, just like a bank.We need a way for the payee to know that the previous owners did not sign any earliertransactions. For our purposes, the earliest transaction is the one that counts, so we don't careabout later attempts to double-spend. The only way to confirm the absence of a transaction is tobe aware of all transactions. In the mint based model, the mint was aware of all transactions anddecided which arrived first",
          "metadata": {
            "pages": [
              1
            ],
            "doc_id": "1QPUdDN71t-VWQoxNbhrBSHRCvyP8hN8x",
            "doc_name": "bitcoin.pdf",
            "childRange": [
              0,
              30
            ],
            "department": "Legal",
            "chunk_index": 5,
            "parentRange": null,
            "indexed_date": "2026-02-15T22:31:24.957Z",
            "document_date": "2008-10-31",
            "cascading_path": "Document",
            "content_length": 865,
            "document_summary": "This document presents Bitcoin's design as a peer-to-peer electronic cash system that enables direct online payments without relying on trusted third parties, using proof-of-work to solve double-spending.",
            "split_part_number": 6,
            "total_chunks_in_section": 31,
            "document_headline_description": "A foundational paper on Bitcoin's peer-to-peer electronic cash"
          },
          "dense_score": 0.128271006242693,
          "sparse_score": 0,
          "ilike_score": 0,
          "fuzzy_score": 0,
          "final_score": 0.00476190476190476
        }
      },
      {
        "json": {
          "id": 2028,
          "content": "This chunk is from a foundational paper on Bitcoin's peer-to-peer electronic cash, specifically # Document (Part 23)\n\n. We can calculate the probability he everreaches breakeven, or that an attacker ever catches up with the honest chain, as follows [8]:p = probability an honest node finds the next blockq = probability the attacker finds the next blockqz = probability the attacker will ever catch up from z blocks behindq z={ 1 if pâ‰¤qî‚žq / pî‚Ÿz if pî‚…q}6Identities Transactions TrustedThird Party Counterparty PublicIdentities Transactions PublicNew Privacy ModelTraditional Privacy ModelGiven our assumption that p > q, the probability drops exponentially as the number of blocks theattacker has to catch up with increases",
          "metadata": {
            "pages": [
              1
            ],
            "doc_id": "1QPUdDN71t-VWQoxNbhrBSHRCvyP8hN8x",
            "doc_name": "bitcoin.pdf",
            "childRange": [
              0,
              30
            ],
            "department": "Legal",
            "chunk_index": 22,
            "parentRange": null,
            "indexed_date": "2026-02-15T22:31:24.958Z",
            "document_date": "2008-10-31",
            "cascading_path": "Document",
            "content_length": 722,
            "document_summary": "This document presents Bitcoin's design as a peer-to-peer electronic cash system that enables direct online payments without relying on trusted third parties, using proof-of-work to solve double-spending.",
            "split_part_number": 23,
            "total_chunks_in_section": 31,
            "document_headline_description": "A foundational paper on Bitcoin's peer-to-peer electronic cash"
          },
          "dense_score": 0.124458581209184,
          "sparse_score": 0,
          "ilike_score": 0,
          "fuzzy_score": 0,
          "final_score": 0.00470588235294118
        }
      },
      {
        "json": {
          "id": 2035,
          "content": "This chunk is from a foundational paper on Bitcoin's peer-to-peer electronic cash, specifically # Document (Part 30)\n\n. Any needed rules and incentives can be enforced with this consensus mechanism.8References[1] W. Dai, \"b-money,\" http://www.weidai.com/bmoney.txt, 1998.[2] H. Massias, X.S. Avila, and J.-J. Quisquater, \"Design of a secure timestamping service with minimaltrust requirements,\" In 20th Symposium on Information Theory in the Benelux, May 1999.[3] S. Haber, W.S. Stornetta, \"How to time-stamp a digital document,\" In Journal of Cryptology, vol 3, no2, pages 99-111, 1991.[4] D. Bayer, S. Haber, W.S. Stornetta, \"Improving the efficiency and reliability of digital time-stamping,\"In Sequences II: Methods in Communication, Security and Computer Science, pages 329-334, 1993.[5] S. Haber, W.S",
          "metadata": {
            "pages": [
              1
            ],
            "doc_id": "1QPUdDN71t-VWQoxNbhrBSHRCvyP8hN8x",
            "doc_name": "bitcoin.pdf",
            "childRange": [
              0,
              30
            ],
            "department": "Legal",
            "chunk_index": 29,
            "parentRange": null,
            "indexed_date": "2026-02-15T22:31:24.958Z",
            "document_date": "2008-10-31",
            "cascading_path": "Document",
            "content_length": 806,
            "document_summary": "This document presents Bitcoin's design as a peer-to-peer electronic cash system that enables direct online payments without relying on trusted third parties, using proof-of-work to solve double-spending.",
            "split_part_number": 30,
            "total_chunks_in_section": 31,
            "document_headline_description": "A foundational paper on Bitcoin's peer-to-peer electronic cash"
          },
          "dense_score": 0.119687366755667,
          "sparse_score": 0,
          "ilike_score": 0,
          "fuzzy_score": 0,
          "final_score": 0.00465116279069767
        }
      },
      {
        "json": {
          "id": 2029,
          "content": "This chunk is from a foundational paper on Bitcoin's peer-to-peer electronic cash, specifically # Document (Part 24)\n\n. With the odds against him, if he doesn't make a luckylunge forward early on, his chances become vanishingly small as he falls further behind.We now consider how long the recipient of a new transaction needs to wait before beingsufficiently certain the sender can't change the transaction. We assume the sender is an attackerwho wants to make the recipient believe he paid him for a while, then switch it to pay back tohimself after some time has passed. The receiver will be alerted when that happens, but thesender hopes it will be too late.The receiver generates a new key pair and gives the public key to the sender shortly beforesigning",
          "metadata": {
            "pages": [
              1
            ],
            "doc_id": "1QPUdDN71t-VWQoxNbhrBSHRCvyP8hN8x",
            "doc_name": "bitcoin.pdf",
            "childRange": [
              0,
              30
            ],
            "department": "Legal",
            "chunk_index": 23,
            "parentRange": null,
            "indexed_date": "2026-02-15T22:31:24.958Z",
            "document_date": "2008-10-31",
            "cascading_path": "Document",
            "content_length": 760,
            "document_summary": "This document presents Bitcoin's design as a peer-to-peer electronic cash system that enables direct online payments without relying on trusted third parties, using proof-of-work to solve double-spending.",
            "split_part_number": 24,
            "total_chunks_in_section": 31,
            "document_headline_description": "A foundational paper on Bitcoin's peer-to-peer electronic cash"
          },
          "dense_score": 0.106562024746062,
          "sparse_score": 0,
          "ilike_score": 0,
          "fuzzy_score": 0,
          "final_score": 0.00459770114942529
        }
      },
      {
        "json": {
          "id": 2009,
          "content": "This chunk is from a foundational paper on Bitcoin's peer-to-peer electronic cash, specifically # Document (Part 4)\n\n. These costs and payment uncertaintiescan be avoided in person by using physical currency, but no mechanism exists to make paymentsover a communications channel without a trusted party.What is needed is an electronic payment system based on cryptographic proof instead of trust,allowing any two willing parties to transact directly with each other without the need for a trustedthird party. Transactions that are computationally impractical to reverse would protect sellersfrom fraud, and routine escrow mechanisms could easily be implemented to protect buyers. Inthis paper, we propose a solution to the double-spending problem using a peer-to-peer distributedtimestamp server to generate computational proof of the chronological order of transactions",
          "metadata": {
            "pages": [
              1
            ],
            "doc_id": "1QPUdDN71t-VWQoxNbhrBSHRCvyP8hN8x",
            "doc_name": "bitcoin.pdf",
            "childRange": [
              0,
              30
            ],
            "department": "Legal",
            "chunk_index": 3,
            "parentRange": null,
            "indexed_date": "2026-02-15T22:31:24.957Z",
            "document_date": "2008-10-31",
            "cascading_path": "Document",
            "content_length": 870,
            "document_summary": "This document presents Bitcoin's design as a peer-to-peer electronic cash system that enables direct online payments without relying on trusted third parties, using proof-of-work to solve double-spending.",
            "split_part_number": 4,
            "total_chunks_in_section": 31,
            "document_headline_description": "A foundational paper on Bitcoin's peer-to-peer electronic cash"
          },
          "dense_score": 0.10629791654932,
          "sparse_score": 0,
          "ilike_score": 0,
          "fuzzy_score": 0,
          "final_score": 0.00454545454545455
        }
      },
      {
        "json": {
          "id": 2008,
          "content": "This chunk is from a foundational paper on Bitcoin's peer-to-peer electronic cash, specifically # Document (Part 3)\n\n. While the system works well enough formost transactions, it still suffers from the inherent weaknesses of the trust based model.Completely non-reversible transactions are not really possible, since financial institutions cannotavoid mediating disputes. The cost of mediation increases transaction costs, limiting theminimum practical transaction size and cutting off the possibility for small casual transactions,and there is a broader cost in the loss of ability to make non-reversible payments for non-reversible services. With the possibility of reversal, the need for trust spreads. Merchants mustbe wary of their customers, hassling them for more information than they would otherwise need.A certain percentage of fraud is accepted as unavoidable",
          "metadata": {
            "pages": [
              1
            ],
            "doc_id": "1QPUdDN71t-VWQoxNbhrBSHRCvyP8hN8x",
            "doc_name": "bitcoin.pdf",
            "childRange": [
              0,
              30
            ],
            "department": "Legal",
            "chunk_index": 2,
            "parentRange": null,
            "indexed_date": "2026-02-15T22:31:24.957Z",
            "document_date": "2008-10-31",
            "cascading_path": "Document",
            "content_length": 870,
            "document_summary": "This document presents Bitcoin's design as a peer-to-peer electronic cash system that enables direct online payments without relying on trusted third parties, using proof-of-work to solve double-spending.",
            "split_part_number": 3,
            "total_chunks_in_section": 31,
            "document_headline_description": "A foundational paper on Bitcoin's peer-to-peer electronic cash"
          },
          "dense_score": 0.105885634352473,
          "sparse_score": 0,
          "ilike_score": 0,
          "fuzzy_score": 0,
          "final_score": 0.00449438202247191
        }
      },
      {
        "json": {
          "id": 2031,
          "content": "This chunk is from a foundational paper on Bitcoin's peer-to-peer electronic cash, specifically # Document (Part 26)\n\n. He doesn't know the exact amount of progress the attacker has made, butassuming the honest blocks took the average expected time per block, the attacker's potentialprogress will be a Poisson distribution with expected value:îƒ=z qpTo get the probability the attacker could still catch up now, we multiply the Poisson density foreach amount of progress he could have made by the probability he could catch up from that point:âˆ‘k =0âˆž îƒk eâˆ’îƒk! â‹…{î‚žq / pî‚Ÿî‚ž zâˆ’k î‚Ÿ if k â‰¤ z1 if k î‚… z}Rearranging to avoid summing the infinite tail of the distribution...1âˆ’âˆ‘k =0z îƒk eâˆ’îƒk! î‚ž1âˆ’î‚žq / pî‚Ÿî‚ž zâˆ’ k î‚Ÿî‚ŸConverting to C code...#include <math.h>double AttackerSuccessProbability(double q, int z){double p = 1.0 - q;double lambda = z * (q / p);double sum = 1.0;int i, k;for (k = 0; k <= z; k++){double poisson =",
          "metadata": {
            "pages": [
              1
            ],
            "doc_id": "1QPUdDN71t-VWQoxNbhrBSHRCvyP8hN8x",
            "doc_name": "bitcoin.pdf",
            "childRange": [
              0,
              30
            ],
            "department": "Legal",
            "chunk_index": 25,
            "parentRange": null,
            "indexed_date": "2026-02-15T22:31:24.958Z",
            "document_date": "2008-10-31",
            "cascading_path": "Document",
            "content_length": 906,
            "document_summary": "This document presents Bitcoin's design as a peer-to-peer electronic cash system that enables direct online payments without relying on trusted third parties, using proof-of-work to solve double-spending.",
            "split_part_number": 26,
            "total_chunks_in_section": 31,
            "document_headline_description": "A foundational paper on Bitcoin's peer-to-peer electronic cash"
          },
          "dense_score": 0.0702978956965711,
          "sparse_score": 0,
          "ilike_score": 0,
          "fuzzy_score": 0,
          "final_score": 0.00444444444444444
        }
      }
    ]
  },
  "connections": {
    "Supabase Short-Term Memory": {
      "ai_memory": [
        [
          {
            "node": "Agentic RAG 1",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Supabase Short-Term Memory2": {
      "ai_memory": [
        [
          {
            "node": "Agentic RAG 3",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Get Long Term Memories": {
      "main": [
        [
          {
            "node": "Agentic RAG 3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "user_id": {
      "main": [
        [
          {
            "node": "Get Long Term Memories",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Query Tabular Rows1": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 3",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Get datasets from record_manager1": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 3",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Query Knowledge Graph2": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 2",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Supabase Short-Term Memory3": {
      "ai_memory": [
        [
          {
            "node": "Agentic RAG 2",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Query Tabular Rows2": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 2",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Get datasets from record_manager2": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 2",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Anthropic Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "Agentic RAG 2",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Anthropic Chat Model2": {
      "ai_languageModel": [
        [
          {
            "node": "Agentic RAG 3",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Dynamic Hybrid Search1": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 2",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Dynamic Hybrid Search2": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 3",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Document Hierarchy": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 1",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Context Expansion": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 1",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Document Hierarchy1": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 2",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Context Expansion1": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 2",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Query Knowledge Graph1": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 3",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Document Hierarchy2": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 3",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Context Expansion2": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 3",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Agentic RAG 3": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          },
          {
            "node": "Execute workflow - Save Zep long term memories",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "When Executed by Another Workflow": {
      "main": [
        [
          {
            "node": "Switch2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Embedding From Query": {
      "main": [
        [
          {
            "node": "Trigger Dynamic Hybrid Search",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Rerank with Cohere 3.5": {
      "main": [
        [
          {
            "node": "Return Reordered Items1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Array": {
      "main": [
        [
          {
            "node": "Rerank with Cohere 3.5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If3": {
      "main": [
        [
          {
            "node": "Create Array",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch2": {
      "main": [
        [
          {
            "node": "Chat Memory Manager",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Query Graph",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Query Graph": {
      "main": [
        [
          {
            "node": "Tidy up response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Chat Memory Manager": {
      "main": [
        [
          {
            "node": "Fetch Metadata Fields1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model4": {
      "ai_languageModel": [
        []
      ]
    },
    "Prep Metadata1": {
      "main": [
        [
          {
            "node": "Generate Embedding From Query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser": {
      "ai_outputParser": [
        [
          {
            "node": "Prep Metadata1",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Metadata Fields1": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prep1": {
      "main": [
        [
          {
            "node": "Prep Metadata1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Supabase Short-Term Memory1": {
      "ai_memory": [
        [
          {
            "node": "Chat Memory Manager",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "Prep1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Generate Embedding From Query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Trigger Dynamic Hybrid Search": {
      "main": [
        [
          {
            "node": "If3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        []
      ]
    },
    "When chat message received": {
      "main": [
        [
          {
            "node": "Agentic RAG 1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dynamic Hybrid Search3": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 1",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Anthropic Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "Agentic RAG 1",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Anthropic Chat Model3": {
      "ai_languageModel": [
        [
          {
            "node": "Prep Metadata1",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "binaryMode": "separate",
    "availableInMCP": false,
    "timeSavedMode": "fixed",
    "callerPolicy": "any"
  },
  "versionId": "94feea14-e848-424f-a28c-550ab8b492c9",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "eaa3d31df30f69d853bf1887372824077726204755d7d83df055afd95f72246a"
  },
  "id": "R_I-MybamT9nBjj0P-Gg3",
  "tags": [
    {
      "updatedAt": "2026-02-15T11:24:19.214Z",
      "createdAt": "2026-02-15T11:24:19.214Z",
      "id": "0wTBNFMNGqp6FfEa",
      "name": "Claude BVIJ"
    },
    {
      "updatedAt": "2026-02-15T13:10:47.882Z",
      "createdAt": "2026-02-15T13:10:47.882Z",
      "id": "Z2OUf4P51HExgS2t",
      "name": "DEV"
    }
  ]
}