{
  "id": "EQTUC67VhmFzuiAB",
  "name": "RAG Retrieval Sub-Workflow v1.0.8c BETA",
  "description": null,
  "active": false,
  "nodes": [
    {
      "parameters": {
        "content": "# State-of-the-Art RAG Agent (With Dynamic Hybrid Search & Context Expansion)",
        "height": 648,
        "width": 1052,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        880,
        16
      ],
      "id": "ca16c45c-98a2-4493-945c-f2388dff653e",
      "name": "Sticky Note6"
    },
    {
      "parameters": {
        "content": "",
        "height": 648,
        "width": 840,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        0,
        0
      ],
      "id": "bde8090e-9d0b-48d0-866e-8baab5130b0b",
      "name": "Sticky Note18"
    },
    {
      "parameters": {
        "contextWindowLength": 10
      },
      "type": "@n8n/n8n-nodes-langchain.memoryPostgresChat",
      "typeVersion": 1.3,
      "position": [
        1072,
        416
      ],
      "id": "95901283-a013-4450-b8e1-89938080cd9f",
      "name": "Supabase Short-Term Memory",
      "credentials": {
        "postgres": {
          "id": "tRlTzpjOmrCVSNLF",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "content": "## v2.3.3\nThis it the agentic inference workflow for both our SOTA RAG System and RAG At Scale System\n\nSOTA RAG Setup instructions here:\nhttps://community.theaiautomators.com/c/automation-templates/state-of-the-art-n8n-rag-agent\n\nRAG at Scale Setup instructions here:\nhttps://community.theaiautomators.com/c/automation-templates/rag-at-scale-system",
        "height": 244,
        "width": 580,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        160,
        368
      ],
      "id": "69ce926d-c901-475b-8a71-20513e15c239",
      "name": "Sticky Note21"
    },
    {
      "parameters": {
        "content": "# State-of-the-Art RAG Agent (With Long Term Memory)",
        "height": 648,
        "width": 2076,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        3440,
        0
      ],
      "id": "c078d511-6a16-418e-932f-6422d246f0e2",
      "name": "Sticky Note20",
      "disabled": true
    },
    {
      "parameters": {
        "name": "Query_Knowledge_Graph",
        "description": "Call this to query data from our knowledge graph",
        "workflowId": {
          "__rl": true,
          "value": "A4BVrX5qYlJ7HUMI",
          "mode": "list",
          "cachedResultName": "TheAIAutomators.com - RAG Masterclass - Lesson 9 - SOTA - v2.0 Dev 0.3"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "query": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('query', ``, 'string') }}",
            "session_id": "={{ $json.sessionId }}",
            "type": "graph"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "query",
              "displayName": "query",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            },
            {
              "id": "type",
              "displayName": "type",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            },
            {
              "id": "session_id",
              "displayName": "session_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        }
      },
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "typeVersion": 2.1,
      "position": [
        4640,
        480
      ],
      "id": "e2c23409-6442-4c40-95ce-1042a25feb57",
      "name": "Query Knowledge Graph1",
      "retryOnFail": true,
      "maxTries": 5,
      "waitBetweenTries": 5000,
      "disabled": true
    },
    {
      "parameters": {
        "contextWindowLength": 10
      },
      "type": "@n8n/n8n-nodes-langchain.memoryPostgresChat",
      "typeVersion": 1.3,
      "position": [
        3984,
        480
      ],
      "id": "2a7354c8-fd2e-4476-bfdc-5d88da321f37",
      "name": "Supabase Short-Term Memory2",
      "credentials": {
        "postgres": {
          "id": "tRlTzpjOmrCVSNLF",
          "name": "Postgres account"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.getzep.com/api/v2/graph/search",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"user_id\": \"{{ $json.user_id }}\",\n  \"query\": {{ JSON.stringify($('When chat message received').item.json.chatInput) }},\n  \"scope\": \"edges\",\n  \"limit\": 5,\n  \"search_filters\": {\n    \"min_relevance\": 0.7\n  }\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        3872,
        224
      ],
      "id": "2a0f1864-0621-46ac-971a-ba91368798a1",
      "name": "Get Long Term Memories",
      "disabled": true
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [
        4784,
        288
      ],
      "id": "5ee05bf7-60e5-4c49-bf80-4d12e06ac217",
      "name": "Respond to Webhook",
      "disabled": true
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "c2e95998-ad5f-4676-b307-b91f5c4adaad",
              "name": "user_id",
              "value": "user1234",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        3616,
        224
      ],
      "id": "853c9e91-d3b0-4578-b64d-30aba5dd1330",
      "name": "user_id",
      "disabled": true
    },
    {
      "parameters": {
        "content": "Note: This template uses n8n chat and by default, this long term memory is shared across all chat sessions. To maintain separate long term memories for different users, check out our community post here, as there are multiple approaches for this depending on how you're deploying the agent. ",
        "height": 192,
        "width": 256,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        3536,
        400
      ],
      "typeVersion": 1,
      "id": "60458bf3-3273-4acb-a7eb-bffdecbf22bd",
      "name": "Sticky Note25",
      "disabled": true
    },
    {
      "parameters": {
        "content": "## TODO\n### Add User ID here",
        "height": 232,
        "width": 232
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        3552,
        144
      ],
      "id": "a58acc54-8665-4d55-b6a2-80b96ad3d087",
      "name": "Sticky Note26",
      "disabled": true
    },
    {
      "parameters": {
        "descriptionType": "manual",
        "toolDescription": "Execute a SQL query on the tabular_document_rows table.\n\nInstructions:\n\nYou will always be querying based on a specific id.\n\nEach row in the table contains a row_data field (of type jsonb) that holds the data for that row, with keys matching the file schema defined in the record_manager table.\n\nThe record_manager_id is the id field from the record_manager table. Always filter based on this specific id when querying the tabular_document_rows table.\n\nWhen writing your SELECT clause, extract values from the row_data JSON using the ->> operator and cast them as needed (e.g., to numeric for calculations).\n\nItems within your SELECT needs to use the data within row_data field.\n\nExample query: Find maximum value for a field (e.g. \"profit\")\n\nSELECT MAX((row_data->>'profit')::numeric) AS max_profit\nFROM tabular_document_rows\nWHERE file_id = '123';\n\nExample query: Group and aggregate (e.g. total revenue by country)\n\nSELECT row_data->>'country' AS country,\n       SUM((row_data->>'revenue')::numeric) AS total_revenue\nFROM tabular_document_rows\nWHERE record_manager_id = '123'\nGROUP BY row_data->>'country';\n\nExample query: Group and aggregate (e.g. total revenue by country)\nSELECT row_data->>'salesperson' AS salesperson,\n       SUM((row_data->>'profit')::numeric) AS total_profit\nFROM tabular_document_rows\nWHERE record_manager_id = '123'\nGROUP BY row_data->>'salesperson';",
        "operation": "executeQuery",
        "query": "{{ $fromAI('sql_query') }}",
        "options": {}
      },
      "type": "n8n-nodes-base.postgresTool",
      "typeVersion": 2.5,
      "position": [
        4304,
        480
      ],
      "id": "adc11b7e-024f-469d-a7da-fc3d631fdbeb",
      "name": "Query Tabular Rows1",
      "credentials": {
        "postgres": {
          "id": "tRlTzpjOmrCVSNLF",
          "name": "Postgres account"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "descriptionType": "manual",
        "toolDescription": "Use this tool to fetch all available documents from the record_manager, this will include the table schema and the id",
        "operation": "select",
        "schema": {
          "__rl": true,
          "mode": "list",
          "value": "public"
        },
        "table": {
          "__rl": true,
          "value": "record_manager_v2",
          "mode": "list",
          "cachedResultName": "record_manager_v2"
        },
        "returnAll": true,
        "where": {
          "values": [
            {
              "column": "data_type",
              "value": "tabular"
            }
          ]
        },
        "options": {
          "outputColumns": [
            "id",
            "document_title",
            "schema"
          ]
        }
      },
      "type": "n8n-nodes-base.postgresTool",
      "typeVersion": 2.5,
      "position": [
        4144,
        480
      ],
      "id": "d021db19-5ada-4945-bf0f-fab3fbe0beaf",
      "name": "Get datasets from record_manager1",
      "credentials": {
        "postgres": {
          "id": "tRlTzpjOmrCVSNLF",
          "name": "Postgres account"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "content": "## TODO\n### Run this node once to manually create a Zep user",
        "height": 312,
        "width": 232
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        5184,
        192
      ],
      "id": "9e06fc04-8d35-4816-9e5c-675dba200b05",
      "name": "Sticky Note27",
      "disabled": true
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "jfvPAjwlf1jVaW3Y",
          "mode": "list",
          "cachedResultName": "Zep - Update Long Term Memories - BLUEPRINT"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "session_id": "={{ $('When chat message received').item.json.sessionId }}",
            "user_id": "={{ $('user_id').item.json.user_id }}",
            "message_content": "={{ $('When chat message received').item.json.chatInput }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "session_id",
              "displayName": "session_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            },
            {
              "id": "user_id",
              "displayName": "user_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            },
            {
              "id": "message_content",
              "displayName": "message_content",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {
          "waitForSubWorkflow": false
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        4784,
        80
      ],
      "id": "309bebe2-56ff-4749-9f3c-a06e605ebb07",
      "name": "Execute workflow - Save Zep long term memories",
      "disabled": true
    },
    {
      "parameters": {
        "public": true,
        "options": {
          "responseMode": "lastNode"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.chatTrigger",
      "typeVersion": 1.3,
      "position": [
        352,
        176
      ],
      "id": "56db4315-437a-4cd4-a921-10aecee9a130",
      "name": "When chat message received",
      "webhookId": "7a862501-e0cf-4205-b97d-c13e3201fb59"
    },
    {
      "parameters": {
        "name": "Query_Knowledge_Graph",
        "description": "Call this to query data from our knowledge graph",
        "workflowId": {
          "__rl": true,
          "value": "suQZAl0QM15VyY3R",
          "mode": "list",
          "cachedResultUrl": "/workflow/suQZAl0QM15VyY3R",
          "cachedResultName": "TheAIAutomators.com - SOTA RAG AGENT - v2.3 Blueprint"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "query": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('query', ``, 'string') }}",
            "session_id": "={{ $json.sessionId }}",
            "type": "graph"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "query",
              "displayName": "query",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            },
            {
              "id": "type",
              "displayName": "type",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            },
            {
              "id": "session_id",
              "displayName": "session_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        }
      },
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "typeVersion": 2.1,
      "position": [
        2864,
        448
      ],
      "id": "a9719c9b-8877-4f6d-91ba-ec37bac5cd06",
      "name": "Query Knowledge Graph2",
      "retryOnFail": true,
      "maxTries": 5,
      "waitBetweenTries": 5000,
      "disabled": true
    },
    {
      "parameters": {
        "contextWindowLength": 10
      },
      "type": "@n8n/n8n-nodes-langchain.memoryPostgresChat",
      "typeVersion": 1.3,
      "position": [
        2192,
        448
      ],
      "id": "6d19e558-e4af-4ad4-a422-e5871998a0ee",
      "name": "Supabase Short-Term Memory3",
      "credentials": {
        "postgres": {
          "id": "tRlTzpjOmrCVSNLF",
          "name": "Postgres account"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "descriptionType": "manual",
        "toolDescription": "Execute a SQL query on the tabular_document_rows table. \n\nInstructions:\n\nYou will always be querying based on a specific id.\n\nEach row in the table contains a row_data field (of type jsonb) that holds the data for that row, with keys matching the file schema defined in the record_manager table.\n\nThe record_manager_id is the id field from the record_manager table. Always filter based on this specific id when querying the tabular_document_rows table.\n\nWhen writing your SELECT clause, extract values from the row_data JSON using the ->> operator and cast them as needed (e.g., to numeric for calculations).\n\nWhen applying WHERE clauses, you should run SELECT DISTINCT queries (LIMIT 100) on the relevant fields first to understand the valid options. This applies even if the user provides a specific value—you must verify that the value exists in the data before using it.\n\nDo NOT run SELECT DISTINCT queries for ID columns.\n\nItems within your SELECT needs to use the data within row_data field.\n\nExample query: Find maximum value for a field (e.g. \"profit\")\n\nSELECT MAX((row_data->>'profit')::numeric) AS max_profit\nFROM tabular_document_rows\nWHERE file_id = '123';\n\nExample query: Group and aggregate (e.g. total revenue by country)\n\nSELECT row_data->>'country' AS country,\n       SUM((row_data->>'revenue')::numeric) AS total_revenue\nFROM tabular_document_rows\nWHERE record_manager_id = '123'\nGROUP BY row_data->>'country';\n\nExample query: Group and aggregate (e.g. total revenue by country)\nSELECT row_data->>'salesperson' AS salesperson,\n       SUM((row_data->>'profit')::numeric) AS total_profit\nFROM tabular_document_rows\nWHERE record_manager_id = '123'\nGROUP BY row_data->>'salesperson';",
        "operation": "executeQuery",
        "query": "{{ $fromAI('sql_query') }}",
        "options": {}
      },
      "type": "n8n-nodes-base.postgresTool",
      "typeVersion": 2.5,
      "position": [
        2512,
        448
      ],
      "id": "27d86b22-453e-4918-93b9-5d048c4a2246",
      "name": "Query Tabular Rows2",
      "credentials": {
        "postgres": {
          "id": "tRlTzpjOmrCVSNLF",
          "name": "Postgres account"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "descriptionType": "manual",
        "toolDescription": "Use this tool to fetch all available documents from the record_manager, this will include the table schema and the id",
        "operation": "select",
        "schema": {
          "__rl": true,
          "mode": "list",
          "value": "public"
        },
        "table": {
          "__rl": true,
          "value": "record_manager_v2",
          "mode": "list",
          "cachedResultName": "record_manager_v2"
        },
        "returnAll": true,
        "where": {
          "values": [
            {
              "column": "data_type",
              "value": "tabular"
            }
          ]
        },
        "options": {
          "outputColumns": [
            "id",
            "document_title",
            "schema"
          ]
        }
      },
      "type": "n8n-nodes-base.postgresTool",
      "typeVersion": 2.5,
      "position": [
        2352,
        448
      ],
      "id": "64c2c123-01a7-4f95-8b1a-542161a70a2d",
      "name": "Get datasets from record_manager2",
      "credentials": {
        "postgres": {
          "id": "tRlTzpjOmrCVSNLF",
          "name": "Postgres account"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "content": "# State-of-the-Art RAG Agent (With GraphRAG + NLQ)",
        "height": 648,
        "width": 1468,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        1936,
        0
      ],
      "id": "65278302-7244-4eaf-91cf-c13de79050c8",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "content": "## TODO\n### Connect the Chat Trigger to your Agent of Choice",
        "height": 256,
        "width": 576
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        160,
        80
      ],
      "id": "5da10bd0-0174-4c98-bf88-faaacb6072fb",
      "name": "Sticky Note29"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "claude-sonnet-4-5-20250929",
          "mode": "list",
          "cachedResultName": "Claude Sonnet 4.5"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
      "typeVersion": 1.3,
      "position": [
        2032,
        448
      ],
      "id": "815bf158-4f29-4a8b-9326-82fe52823054",
      "name": "Anthropic Chat Model1",
      "credentials": {
        "anthropicApi": {
          "id": "UyAehXbUNQAWwZOs",
          "name": "Claude SEB"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "claude-sonnet-4-5-20250929",
          "mode": "list",
          "cachedResultName": "Claude Sonnet 4.5"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
      "typeVersion": 1.3,
      "position": [
        3824,
        480
      ],
      "id": "374162be-5efc-444b-b507-09510f7fc072",
      "name": "Anthropic Chat Model2",
      "credentials": {
        "anthropicApi": {
          "id": "UyAehXbUNQAWwZOs",
          "name": "Claude SEB"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "description": "=Call this tool to query data from our knowledgebase using hybrid search (vector, lexical, ilike and fuzzy)\n\nYou can set different weights of this hybrid search depending on the type of query.\n\ndense_weight float DEFAULT 0.5,\nsparse_weight float DEFAULT 0.5,\nilike_weight float DEFAULT 0\nfuzzy_weight float DEFAULT 0\nfuzzy_threshold float DEFAULT 0.8\n\nFor semantic natural lanauge queries you can prioritise dense embeddings, \nFor technical terms and more traditional search you can priorize sparse lexical search\nFor exact matches for codes and IDs you can prioritze ilike wildcard matching\nFor typos that aren't picked up by semantic search, you can prioritize fuzzy matching\n\nIf looking for matches via ilike or fuzzy matches, the query should be extremely focused and short, as otherwise it will likely return zero results. (e.g. exact ID or code)\n\nAs pattern matching and fuzzy matching can add latency, I recommend defaulting this to zero unless you want to actually use it.\n\nTotal of the 4 weights much equal 1\n\nFuzzy Threshold adds significant latency should should be as high as possible - Default to 0.8",
        "workflowId": {
          "__rl": true,
          "value": "suQZAl0QM15VyY3R",
          "mode": "list",
          "cachedResultUrl": "/workflow/suQZAl0QM15VyY3R",
          "cachedResultName": "TheAIAutomators.com - SOTA RAG AGENT - v2.3 Blueprint"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "query": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('query', ``, 'string') }}",
            "session_id": "={{ $json.sessionId }}",
            "sparse_weight": "={{ $fromAI('sparse_weight', ``, 'number', 0.5) }}",
            "dense_weight": "={{ $fromAI('dense_weight', ``, 'number', 0.5) }}",
            "fuzzy_threshold": "={{ $fromAI('fuzzy_threshold', `this is the word similarity threshold in postgres - lower means more candidates however the call may time out`, 'number', 0.8) }}",
            "fuzzy_weight": "={{ $fromAI('fuzzy_weight', ``, 'number', 0) }}",
            "ilike_weight": "={{ $fromAI('ilike_weight', ``, 'number', 0) }}",
            "type": "hybrid"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "query",
              "displayName": "query",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "type",
              "displayName": "type",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "session_id",
              "displayName": "session_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "dense_weight",
              "displayName": "dense_weight",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            },
            {
              "id": "sparse_weight",
              "displayName": "sparse_weight",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            },
            {
              "id": "ilike_weight",
              "displayName": "ilike_weight",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            },
            {
              "id": "fuzzy_weight",
              "displayName": "fuzzy_weight",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            },
            {
              "id": "fuzzy_threshold",
              "displayName": "fuzzy_threshold",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        }
      },
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "typeVersion": 2.2,
      "position": [
        2688,
        448
      ],
      "id": "873b5782-dfc7-4eec-98eb-8066d1951020",
      "name": "Dynamic Hybrid Search1",
      "disabled": true
    },
    {
      "parameters": {
        "description": "=Call this tool to query data from our knowledgebase using hybrid search (vector, lexical, ilike and fuzzy)\n\nYou can set different weights of this hybrid search depending on the type of query.\n\ndense_weight float DEFAULT 0.5,\nsparse_weight float DEFAULT 0.5,\nilike_weight float DEFAULT 0\nfuzzy_weight float DEFAULT 0\nfuzzy_threshold float DEFAULT 0.8\n\nFor semantic natural lanauge queries you can prioritise dense embeddings, \nFor technical terms and more traditional search you can priorize sparse lexical search\nFor exact matches for codes and IDs you can prioritze ilike wildcard matching\nFor typos that aren't picked up by semantic search, you can prioritize fuzzy matching\n\nIf looking for matches via ilike or fuzzy matches, the query should be extremely focused and short, as otherwise it will likely return zero results. (e.g. exact ID or code)\n\nAs pattern matching and fuzzy matching can add latency, I recommend defaulting this to zero unless you want to actually use it.\n\nTotal of the 4 weights much equal 1\n\nFuzzy Threshold adds significant latency should should be as high as possible - Default to 0.8",
        "workflowId": {
          "__rl": true,
          "value": "BBep2uTA4ZltoqZF",
          "mode": "list",
          "cachedResultName": "TheAIAutomators.com - SOTA RAG AGENT - v2.2 Active"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "query": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('query', ``, 'string') }}",
            "session_id": "={{ $json.sessionId }}",
            "sparse_weight": "={{ $fromAI('sparse_weight', ``, 'number', 0.5) }}",
            "dense_weight": "={{ $fromAI('dense_weight', ``, 'number', 0.5) }}",
            "fuzzy_threshold": "={{ $fromAI('fuzzy_threshold', `this is the word similarity threshold in postgres - lower means more candidates however the call may time out`, 'number', 0.8) }}",
            "fuzzy_weight": "={{ $fromAI('fuzzy_weight', ``, 'number', 0) }}",
            "ilike_weight": "={{ $fromAI('ilike_weight', ``, 'number', 0) }}",
            "type": "hybrid"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "query",
              "displayName": "query",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "type",
              "displayName": "type",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "session_id",
              "displayName": "session_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "dense_weight",
              "displayName": "dense_weight",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            },
            {
              "id": "sparse_weight",
              "displayName": "sparse_weight",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            },
            {
              "id": "ilike_weight",
              "displayName": "ilike_weight",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            },
            {
              "id": "fuzzy_weight",
              "displayName": "fuzzy_weight",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            },
            {
              "id": "fuzzy_threshold",
              "displayName": "fuzzy_threshold",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        }
      },
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "typeVersion": 2.2,
      "position": [
        4480,
        480
      ],
      "id": "55e5df38-2cbf-4098-b4a4-27d6a4ab9890",
      "name": "Dynamic Hybrid Search2",
      "disabled": true
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "record_manager_v2",
        "limit": 1,
        "filters": {
          "conditions": [
            {
              "keyName": "doc_id",
              "condition": "eq",
              "keyValue": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('conditions0_Field_Value', ``, 'string') }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabaseTool",
      "typeVersion": 1,
      "position": [
        1584,
        448
      ],
      "id": "ce751b08-7091-4960-8931-40ef44ab8fdf",
      "name": "Fetch Document Hierarchy",
      "credentials": {
        "supabaseApi": {
          "id": "JXvQLWfqIjdcMyqm",
          "name": "Supabase B5rman"
        }
      }
    },
    {
      "parameters": {
        "toolDescription": "Based on the most promising chunks retrieved from the knowledgebase, use this tool to expand out the context by fetching neighbouring chunks, parent chunks etc\n\nThe body of this call must be in this format and the values you need are in the chunk metadata. You can retrieve chunks from one or multiple documents if you like\n[\n    {\n      doc_id: \"doc-id-12345-abcde\",\n      chunk_ranges: [[0, 5]]\n    },\n    {\n      doc_id: \"another-doc-id-12345\",\n      chunk_ranges: [[10, 15], [20, 25]]\n    }\n  ]\n",
        "method": "POST",
        "url": "https://mgistrmwhxccyuchokbh.supabase.co/functions/v1/context-expansion",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('JSON', ``, 'json') }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequestTool",
      "typeVersion": 4.2,
      "position": [
        1760,
        448
      ],
      "id": "a82be180-6f2d-4dd0-88e7-208e5fee4b02",
      "name": "Context Expansion",
      "credentials": {
        "supabaseApi": {
          "id": "JXvQLWfqIjdcMyqm",
          "name": "Supabase B5rman"
        }
      }
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "record_manager_v2",
        "limit": 1,
        "filters": {
          "conditions": [
            {
              "keyName": "doc_id",
              "condition": "eq",
              "keyValue": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('conditions0_Field_Value', ``, 'string') }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabaseTool",
      "typeVersion": 1,
      "position": [
        3024,
        448
      ],
      "id": "d7d55da9-048f-4f26-970e-321c46c1f438",
      "name": "Fetch Document Hierarchy1",
      "credentials": {
        "supabaseApi": {
          "id": "JXvQLWfqIjdcMyqm",
          "name": "Supabase B5rman"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "toolDescription": "Based on the most promising chunks retrieved from the knowledgebase, use this tool to expand out the context by fetching neighbouring chunks, parent chunks etc\n\nThe body of this call must be in this format and the values you need are in the chunk metadata. You can retrieve chunks from one or multiple documents if you like\n[\n    {\n      doc_id: \"doc-id-12345-abcde\",\n      chunk_ranges: [[0, 5]]\n    },\n    {\n      doc_id: \"another-doc-id-12345\",\n      chunk_ranges: [[10, 15], [20, 25]]\n    }\n  ]\n",
        "method": "POST",
        "url": "https://iwcionhpeltdhfrtimtp.supabase.co/functions/v1/context-expansion",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('JSON', ``, 'json') }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequestTool",
      "typeVersion": 4.2,
      "position": [
        3200,
        448
      ],
      "id": "31a2f10a-76f7-45b3-9dd7-2b398c684e15",
      "name": "Context Expansion1",
      "disabled": true
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "record_manager_v2",
        "limit": 1,
        "filters": {
          "conditions": [
            {
              "keyName": "doc_id",
              "condition": "eq",
              "keyValue": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('conditions0_Field_Value', ``, 'string') }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabaseTool",
      "typeVersion": 1,
      "position": [
        4800,
        480
      ],
      "id": "bad1f3df-ab40-4483-9eba-ca190d89e510",
      "name": "Fetch Document Hierarchy2",
      "credentials": {
        "supabaseApi": {
          "id": "JXvQLWfqIjdcMyqm",
          "name": "Supabase B5rman"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "toolDescription": "Based on the most promising chunks retrieved from the knowledgebase, use this tool to expand out the context by fetching neighbouring chunks, parent chunks etc\n\nThe body of this call must be in this format and the values you need are in the chunk metadata. You can retrieve chunks from one or multiple documents if you like\n[\n    {\n      doc_id: \"doc-id-12345-abcde\",\n      chunk_ranges: [[0, 5]]\n    },\n    {\n      doc_id: \"another-doc-id-12345\",\n      chunk_ranges: [[10, 15], [20, 25]]\n    }\n  ]\n",
        "method": "POST",
        "url": "https://iwcionhpeltdhfrtimtp.supabase.co/functions/v1/context-expansion",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('JSON', ``, 'json') }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequestTool",
      "typeVersion": 4.2,
      "position": [
        4976,
        480
      ],
      "id": "a1ca7b50-8a9d-4364-916d-2292da9fbd82",
      "name": "Context Expansion2",
      "disabled": true
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $('When chat message received').item.json.chatInput }}",
        "options": {
          "systemMessage": "=# Role\n\nYou are an AI assistant responding to a user's query based on the information provided by multiple knowledgebases - Hybrid Search, Knowledge Graph and Structured datasets.\n\n# Goal\n\nYou are tasked with creating and executing a retrieval strategy to best answer the users question.\n\nThe output should be a well-reserached response to the users query based on the output from these tools and to follow the Operating Procedures and Response Rules as set about below.\n\nYou must consider both the conversation history and the current query.\n\nYour goal is to provide a fully grounded, accurate answer based on the output from these tools ONLY.\n\n# Standard Operating Procedure\n\nBased on your retrieval strategy\n\n## Hybrid Search & Context Expansion\n\n1. Pass relevant query(s) to the dynamic hybrid search to narrow the search and retrieve candidate chunks\n\n2. Based on the most relevant chunk(s); Trigger the Fetch Document Hierarchy Tool to load the source Documents Structure\n\n3. Based on this document structure (which includes chunk ranges) along with any relevant child_ranges and parent_ranges from the retrieved chunks, trigger the Context Expansion tool to expand your insight into the document.\n\n## Tabular Data\n\nIf the question involves tabular data—such as calculating sums, averages, or finding maximum values—the vector store and graph tools may be unreliable. \n\nIn that case, start by reviewing the available datasets, identify the ones most likely to contain the answer, and then construct a SQL query to analyze them.\n\n## Knowledge Graph\n\nIf you are asked questions that you think would be best answered with insights from a knowledge graph then please seach the graph\n\n---Response Rules---\n\n- Ideal target format and length: Multiple Paragraphs\n- Use markdown formatting with appropriate section headings\n- Please respond in the same language as the user's question.\n- If there are images provided from the retrieved information, you should return this in markdown format.\n- Ensure the response maintains continuity with the conversation history.\n- List between 1-5 important reference sources at the end under \"References\" section. (Mark the source as (KB) for Knowledgebase, (GR) for Graph or (DB) for Database). If information is from chunks, then provide Document Names and Page Numbers that these sources appear in the documents - this is in the chunk metadata.\n- Do not make anything up. \n- Do not include information not provided by the Knowledge Bases.\n- If you cannot answer the question using the provided information or if no information is returned from the tools, say \"Sorry I don't know\"."
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.9,
      "position": [
        2400,
        192
      ],
      "id": "83657eb5-e202-45b0-877a-fbda07f4cf28",
      "name": "Agentic RAG 2",
      "retryOnFail": true,
      "maxTries": 5,
      "disabled": true
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $('When chat message received').item.json.chatInput }}",
        "options": {
          "systemMessage": "=# Role\n\nYou are an AI assistant responding to a user's query based on the information provided by multiple knowledgebases - Hybrid Search, Knowledge Graph and Structured datasets.\n\n# Goal\n\nYou are tasked with creating and executing a retrieval strategy to best answer the users question.\n\nThe output should be a well-reserached response to the users query based on the output from these tools and to follow the Operating Procedures and Response Rules as set about below.\n\nYou must consider both the conversation history and the current query.\n\nYour goal is to provide a fully grounded, accurate answer based on the output from these tools ONLY.\n\n# Standard Operating Procedure\n\nBased on your retrieval strategy\n\n## Hybrid Search & Context Expansion\n\n1. Pass relevant query(s) to the dynamic hybrid search to narrow the search and retrieve candidate chunks\n\n2. Based on the most relevant chunk(s); Trigger the Fetch Document Hierarchy Tool to load the source Documents Structure\n\n3. Based on this document structure (which includes chunk ranges) along with any relevant child_ranges and parent_ranges from the retrieved chunks, trigger the Context Expansion tool to expand your insight into the document.\n\n## Tabular Data\n\nIf the question involves tabular data—such as calculating sums, averages, or finding maximum values—the vector store and graph tools may be unreliable. \n\nIn that case, start by reviewing the available datasets, identify the ones most likely to contain the answer, and then construct a SQL query to analyze them.\n\n## Knowledge Graph\n\nIf you are asked questions that you think would be best answered with insights from a knowledge graph then please seach the graph\n\n---Response Rules---\n\n- Ideal target format and length: Multiple Paragraphs\n- Use markdown formatting with appropriate section headings\n- Please respond in the same language as the user's question.\n- If there are images provided from the retrieved information, you should return this in markdown format.\n- Ensure the response maintains continuity with the conversation history.\n- List between 1-5 important reference sources at the end under \"References\" section. (Mark the source as (KB) for Knowledgebase, (GR) for Graph or (DB) for Database). If information is from chunks, then provide Document Names and Page Numbers that these sources appear in the documents - this is in the chunk metadata.\n- Do not make anything up. \n- Do not include information not provided by the Knowledge Bases.\n- If you cannot answer the question using the provided information or if no information is returned from the tools, say \"Sorry I don't know\".\n\n{{\n(() => {\n  const raw = $json.data;\n  if (raw == null) return '';\n\n  const toText = v => (typeof v === 'string' ? v : JSON.stringify(v));\n  const rawText = toText(raw);\n  const cleaned = rawText.replace(/[\\u0000-\\u001F\\u007F]/g, '').trim();\n  if (!cleaned || cleaned === '{}' || cleaned === '[]') return '';\n\n  // Parse only if the cleaned text looks like JSON\n  let obj = raw;\n  if (typeof raw === 'string') {\n    const first = cleaned[0];\n    if (first === '{' || first === '[') {\n      try { obj = JSON.parse(cleaned); } catch { return ''; }\n    } else {\n      return '';\n    }\n  }\n\n  // Support either { edges: [...] } or a bare array of edges\n  const edges = Array.isArray(obj?.edges) ? obj.edges : (Array.isArray(obj) ? obj : []);\n  if (!edges.length) return '';\n\n  const facts = [...new Set(\n    edges\n      .map(e => (e && typeof e.fact === 'string') ? e.fact.replace(/\\s+/g, ' ').trim() : '')\n      .filter(Boolean)\n  )];\n\n  return facts.length\n    ? \"---User Information---\\nThis is information about the user:\\n\" + facts.map(f => \"- \" + f).join(\"\\n\")\n    : '';\n})()\n}}"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.9,
      "position": [
        4080,
        224
      ],
      "id": "39597802-257b-4c60-ad6d-0cc40eab4fe5",
      "name": "Agentic RAG 3",
      "retryOnFail": true,
      "maxTries": 5,
      "disabled": true
    },
    {
      "parameters": {
        "workflowInputs": {
          "values": [
            {
              "name": "query"
            },
            {
              "name": "type"
            },
            {
              "name": "session_id"
            },
            {
              "name": "dense_weight",
              "type": "number"
            },
            {
              "name": "sparse_weight",
              "type": "number"
            },
            {
              "name": "ilike_weight",
              "type": "number"
            },
            {
              "name": "fuzzy_weight",
              "type": "number"
            },
            {
              "name": "fuzzy_threshold",
              "type": "number"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        1008,
        912
      ],
      "id": "3cd272bc-306a-4e59-a4f7-f7b79300e366",
      "name": "When Executed by Another Workflow"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/embeddings",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "openAiApi",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "input",
              "value": "={{ $('When Executed by Another Workflow').item.json.query }}"
            },
            {
              "name": "model",
              "value": "text-embedding-3-small"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        2928,
        912
      ],
      "id": "6a0c9e2a-ef77-4013-b0c7-5883a750dd4d",
      "name": "Generate Embedding From Query",
      "credentials": {
        "openAiApi": {
          "id": "r6dwaEmQxKEvrskM",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.cohere.com/v2/rerank",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "accept",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"rerank-v3.5\",\n  \"query\": \"{{ $('When Executed by Another Workflow').first().json.query }}\",\n  \"top_n\": 10,\n  \"documents\": {{ JSON.stringify($json.documents) }}\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        3984,
        912
      ],
      "id": "48330f59-e9a5-4156-8cdd-9cb8ee1979a1",
      "name": "Rerank with Cohere 3.5",
      "credentials": {
        "httpHeaderAuth": {
          "id": "lSFkzmpI1ZAMZqHr",
          "name": "Cohere"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// --- This Code Node extracts 'content' from multiple input items ---\n\n// Step 1: Use .map() to iterate over ALL incoming items ($input.all()).\n// For each item, access its 'json' property, and then the 'content' field within that.\nconst contentArray = $input.all().map(item => {\n  // Basic safety check: ensure item.json and item.json.content exist.\n  // Return null or an empty string if not found, otherwise return the content.\n  // Adjust the fallback value (null) if needed.\n  return item.json?.content ?? null;\n});\n\n// Step 2: Filter out any potential null values if an item was missing content (optional)\n// If you are certain all items will have content, you can skip this filter.\nconst validContentArray = contentArray.filter(content => content !== null);\n\n// Step 3: Return the result as a *single* new n8n item.\n// This item contains your final array of strings under the 'documents' key.\nreturn [{\n  json: {\n    // Use validContentArray if you filtered, otherwise use contentArray\n    documents: validContentArray\n    // documents: contentArray // <-- Use this if you didn't filter\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3744,
        912
      ],
      "id": "cd2c30c7-e228-4a0f-b8f8-88039a27ea3a",
      "name": "Create Array"
    },
    {
      "parameters": {
        "jsCode": "// --- Code Node to Reorder Items Based on Rerank Results (WITH METADATA) ---\n// Fixed: Handles HTTP Request node response format where results come as\n// a single n8n item containing an array, not as multiple n8n items.\n\n// --- Step 1: Get Data from Input Nodes ---\nconst rawItems = $('Trigger Dynamic Hybrid Search').all();\n\n// HTTP Request nodes return a single n8n item where json IS the array,\n// or json contains the array. We need to normalize to individual items.\nlet originalFullItems;\nif (rawItems.length === 1 && Array.isArray(rawItems[0].json)) {\n  // Case 1: json is directly an array (e.g., [{id:1,...}, {id:2,...}])\n  originalFullItems = rawItems[0].json.map(item => ({ json: item }));\n} else if (rawItems.length === 1 && rawItems[0].json && typeof rawItems[0].json === 'object') {\n  const firstItem = rawItems[0].json;\n  // Case 2: Single object that might be a result itself\n  if (firstItem.content || firstItem.id || firstItem.metadata) {\n    originalFullItems = rawItems;\n  } else {\n    // Case 3: Object wrapping an array (e.g., {data: [...]})\n    const arrayKey = Object.keys(firstItem).find(k => Array.isArray(firstItem[k]));\n    if (arrayKey) {\n      originalFullItems = firstItem[arrayKey].map(item => ({ json: item }));\n    } else {\n      originalFullItems = rawItems;\n    }\n  }\n} else {\n  // Case 4: Already multiple n8n items (normal case)\n  originalFullItems = rawItems;\n}\n\n// Get the rerank results array from the Cohere Rerank node\nconst rerankOrderInfo = $input.first().json.results;\n\n// --- Step 2: Validate Inputs ---\nif (!Array.isArray(originalFullItems) || originalFullItems.length === 0) {\n  return [{ json: { message: 'No original items to reorder', count: 0 } }];\n}\n\nif (!Array.isArray(rerankOrderInfo) || rerankOrderInfo.length === 0) {\n  // No rerank results — return original items as-is\n  return originalFullItems.map(item => ({ json: item.json || item }));\n}\n\n// --- Step 3: Reorder the FULL Items (content + metadata) ---\nconst sortedItems = rerankOrderInfo\n  .map(rankInfo => {\n    const idx = rankInfo.index;\n    if (idx >= 0 && idx < originalFullItems.length) {\n      const originalItem = originalFullItems[idx].json || originalFullItems[idx];\n      return { ...originalItem, rerank_score: rankInfo.relevance_score };\n    }\n    return null;\n  })\n  .filter(item => item !== null);\n\nreturn sortedItems.map(item => ({ json: item }));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4208,
        912
      ],
      "id": "67f1ee96-be4f-4296-93b4-aab84b1a5e95",
      "name": "Return Reordered Items1"
    },
    {
      "parameters": {
        "content": "## Hybrid Search",
        "height": 552,
        "width": 536,
        "color": 6
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        2880,
        768
      ],
      "id": "730743cb-7f0f-49a1-856a-8147cf1d8429",
      "name": "Sticky Note11"
    },
    {
      "parameters": {
        "content": "## Reranking",
        "height": 552,
        "width": 1044,
        "color": 6
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        3424,
        768
      ],
      "id": "a2435299-0d12-41b1-9cf1-645288036d95",
      "name": "Sticky Note12",
      "disabled": true
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 2,
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "loose"
          },
          "conditions": [
            {
              "id": "71326cd6-1316-4b5e-bf34-0d0b3c086005",
              "leftValue": "={{ $('Trigger Dynamic Hybrid Search').item.json.keys().length}}",
              "rightValue": 0,
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        3472,
        912
      ],
      "id": "0b3025e5-7e74-4804-b8a3-7339cd59e8c9",
      "name": "If3",
      "alwaysOutputData": false
    },
    {
      "parameters": {
        "jsCode": "return [{\n  message: \"no documents found\" \n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3744,
        1136
      ],
      "id": "6b918947-38da-44ae-946e-f200ee96d941",
      "name": "Code"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.type }}",
                    "rightValue": "hybrid",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "322d7a20-e584-4a2c-ad39-987298dabdf1"
                  }
                ],
                "combinator": "and"
              }
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "4c020ce0-c212-4e62-9c42-863f0358d065",
                    "leftValue": "={{ $json.type }}",
                    "rightValue": "graph",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              }
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        1200,
        912
      ],
      "id": "b34ebf85-e333-4f95-9d22-5e8ed6284315",
      "name": "Switch2"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://YOUR_LIGHTRAG_URL/query",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"query\": \"{{ $('When Executed by Another Workflow').item.json.query }}\",\n  \"mode\": \"hybrid\",\n  \"only_need_context\": true,\n  \"only_need_prompt\": false,\n  \"response_type\": \"multiple paragraphs\",\n  \"top_k\": 20,\n  \"chunk_top_k\": 1,\n  \"max_entity_tokens\": 10000,\n  \"max_relation_tokens\": 10000,\n  \"max_total_tokens\": 32000,\n  \"enable_rerank\": false\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1904,
        1520
      ],
      "id": "c5b0bb39-47aa-4f4c-9d7c-c0e1cf0994c9",
      "name": "Query Graph",
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "// Loop over input items and extract everything before \"-----Document Chunks(DC)-----\"\nfor (const item of $input.all()) {\n\n  const intro = \"The following entities and relationships were retrived.\\n\\n\"\n  const outro = \"-----How to use this data-----\\n\\nWhen considering relationships with timestamps:\\n\\nEach relationship has a \\\"created_at\\\" timestamp indicating when we acquired this knowledge. When encountering conflicting relationships, consider both the semantic content and the timestamp. Don't automatically prefer the most recently created relationships - use judgment based on the context. For time-specific queries, prioritize temporal information in the content before considering creation timestamps\"\n  \n  // Get the input string - adjust this based on where your string is located\n  const inputString = item.json.response; // Change 'response' to your actual field name\n  \n  // Define the substring to search for\n  const separator = \"-----Document Chunks(DC)-----\";\n  \n  // Find the position of the separator\n  const separatorIndex = inputString.indexOf(separator);\n  \n  let extractedContent = \"\";\n  \n  if (separatorIndex !== -1) {\n    // Extract everything before the separator\n    extractedContent = inputString.substring(0, separatorIndex);\n  } else {\n    // If separator not found, return the entire string\n    extractedContent = inputString;\n  }\n  \n  // Add the extracted content to the item\n  item.json.response = intro + extractedContent + outro;\n\n}\n\nreturn $input.all();"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2144,
        1520
      ],
      "id": "26f041bb-62ef-4b59-ad60-4cce22708a09",
      "name": "Tidy up response",
      "disabled": true
    },
    {
      "parameters": {
        "content": "## Graph Search",
        "height": 348,
        "width": 800,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        1760,
        1376
      ],
      "id": "7f5df697-4041-40ee-b4df-6fde18f43afe",
      "name": "Sticky Note13"
    },
    {
      "parameters": {
        "content": "## Advanced Metadata Filtering",
        "height": 552,
        "width": 1104,
        "color": 6
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        1744,
        768
      ],
      "id": "35a23bf5-a894-4f4f-beee-b927c78c3586",
      "name": "Sticky Note16"
    },
    {
      "parameters": {
        "options": {
          "groupMessages": false
        }
      },
      "type": "@n8n/n8n-nodes-langchain.memoryManager",
      "typeVersion": 1.1,
      "position": [
        1456,
        880
      ],
      "id": "01ab89b1-0fed-43c9-9d2c-90a8489a0e6c",
      "name": "Chat Memory Manager",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=# User Query\n{{ $('When Executed by Another Workflow').first().json.query }}\n\n# Conversation History (if any)\n{{ JSON.stringify($('Chat Memory Manager').first().json) }}",
        "hasOutputParser": true,
        "messages": {
          "messageValues": [
            {
              "message": "=# Task\n\nYour task is to consider the following user query and then consider the following metadata keys with example values that we have that we can limit our result set from.\n\n# Metadata Filters and Possible Values\n\n{{ $json.filterPromptInstructions }}\n\n# Metadata Operators\n\nThe following operators are allowed:\n\n>\n<\n=\n!=\n>=\n<=\nIN\nNOT IN\n\nIF IN or NOT IN are provided, then an array of values must be provided.\n\nNow output a filter array with relevant filters with the following example format. The below filter_categories are just for exampe purposes. Use the \"Metadata Filters and Possible Values\" list above for the list of allowed filters.\n\n[\n    \"filter\": {\n      \"$and\": [\n        {\n          \"category\": {\n            \"operator\": \"IN\",\n            \"value\": [\n              \"F1\",\n              \"Rally\"\n            ]\n          }\n        },\n        {\n          \"year\": {\n            \"operator\": \">\",\n            \"value\": 2024\n          }\n        }\n      ]\n    }\n]\n\nIf the query does not have relevant metadatafilters, then do not output any ... for example\n\n{\n  \"filter\": {}\n}\n\nIf there is only 1 relevant metadafilter, then just output that ... for example\n\n[\n    \"filter\": {\n      \"$and\": [\n        {\n          \"motorsport_category\": {\n            \"operator\": \"IN\",\n            \"value\": [\n              \"F1\",\n              \"Rally\"\n            ]\n          }\n        }\n      ]\n    }\n]\n\nOnly output in JSON\n\nNote: Today's date is {{ $now }}"
            }
          ]
        }
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [
        2480,
        896
      ],
      "id": "b639684c-f9e2-4eca-b058-37d831c6cda2",
      "name": "Prep Metadata1",
      "retryOnFail": true,
      "maxTries": 5
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"FlexibleFilterObject\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"filter\": {\n      \"type\": \"object\",\n      \"oneOf\": [\n        {\n          \"required\": [\"$and\"],\n          \"properties\": {\n            \"$and\": {\n              \"type\": \"array\",\n              \"items\": { \"$ref\": \"#/definitions/condition\" }\n            }\n          },\n          \"additionalProperties\": false\n        },\n        {\n          \"required\": [\"$or\"],\n          \"properties\": {\n            \"$or\": {\n              \"type\": \"array\",\n              \"items\": { \"$ref\": \"#/definitions/condition\" }\n            }\n          },\n          \"additionalProperties\": false\n        },\n        {\n          \"properties\": {},\n          \"additionalProperties\": false\n        }\n      ]\n    }\n  },\n  \"required\": [\"filter\"],\n  \"definitions\": {\n    \"condition\": {\n      \"oneOf\": [\n        {\n          \"type\": \"object\",\n          \"required\": [\"field\", \"operator\", \"value\"],\n          \"properties\": {\n            \"field\": { \"type\": \"string\" },\n            \"operator\": {\n              \"type\": \"string\",\n              \"enum\": [\"=\", \"!=\", \">\", \"<\", \">=\", \"<=\", \"IN\", \"NOT IN\"]\n            },\n            \"value\": {\n              \"oneOf\": [\n                { \"type\": \"string\" },\n                { \"type\": \"number\" },\n                {\n                  \"type\": \"array\",\n                  \"items\": { \"type\": [\"string\", \"number\"] }\n                }\n              ]\n            }\n          },\n          \"additionalProperties\": false\n        },\n        {\n          \"type\": \"object\",\n          \"minProperties\": 1,\n          \"maxProperties\": 1,\n          \"patternProperties\": {\n            \"^.+$\": {\n              \"type\": \"object\",\n              \"required\": [\"operator\", \"value\"],\n              \"properties\": {\n                \"operator\": {\n                  \"type\": \"string\",\n                  \"enum\": [\"=\", \"!=\", \">\", \"<\", \">=\", \"<=\", \"IN\", \"NOT IN\"]\n                },\n                \"value\": {\n                  \"oneOf\": [\n                    { \"type\": \"string\" },\n                    { \"type\": \"number\" },\n                    {\n                      \"type\": \"array\",\n                      \"items\": { \"type\": [\"string\", \"number\"] }\n                    }\n                  ]\n                }\n              },\n              \"additionalProperties\": false\n            }\n          },\n          \"additionalProperties\": false\n        }\n      ]\n    }\n  }\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.2,
      "position": [
        2640,
        1120
      ],
      "id": "7aa52dbe-f464-4faf-b90d-61b43dcc6695",
      "name": "Structured Output Parser"
    },
    {
      "parameters": {
        "content": "# Retrieval Sub-Workflow",
        "height": 552,
        "width": 840,
        "color": 6
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        896,
        768
      ],
      "id": "3e8496ec-cad5-40c7-980f-fcae3bcc4437",
      "name": "Sticky Note17"
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "metadata_fields"
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1824,
        912
      ],
      "id": "78529f6b-ae74-4617-94a5-9f4ae1eded94",
      "name": "Fetch Metadata Fields1",
      "alwaysOutputData": true,
      "credentials": {
        "supabaseApi": {
          "id": "JXvQLWfqIjdcMyqm",
          "name": "Supabase B5rman"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Get input items\nconst items = $input.all();\n\n// Initialize output string\nlet output = '';\n\n// Loop through each input item\nfor (const item of items) {\n  const data = item.json;\n\n  const key = data.metadata_name;\n  const values = data.allowed_values;\n\n  output += `## ${key}\\n`;\n  output += `The filter key ${key} can have the following possible values\\n\\n`;\n  output += `${values.trim()}\\n\\n`;\n}\n\n// Take the first item and modify it with aggregated data\nconst firstItem = items[0];\nfirstItem.json.filterPromptInstructions = output.trim();\n\n// Return only the first item (now containing aggregated data)\nreturn [firstItem];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2256,
        912
      ],
      "id": "68c218f9-2415-46ec-bae6-48adc9be9c7c",
      "name": "Prep1"
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $('When Executed by Another Workflow').item.json.session_id }}",
        "contextWindowLength": {}
      },
      "type": "@n8n/n8n-nodes-langchain.memoryPostgresChat",
      "typeVersion": 1.3,
      "position": [
        1552,
        1072
      ],
      "id": "57f72157-c379-42f5-80ab-0156759214d7",
      "name": "Supabase Short-Term Memory1",
      "credentials": {
        "postgres": {
          "id": "tRlTzpjOmrCVSNLF",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "content": "## TODO\n### Add LightRAG Server URL",
        "height": 252,
        "width": 280
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        1824,
        1424
      ],
      "id": "6bc97bfb-9dcc-4e19-a4bb-de7cfc48ea30",
      "name": "Sticky Note19",
      "disabled": true
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 2,
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "a4697977-31b6-4740-ae7c-0e3a35ecfdf0",
              "leftValue": "={{ $json }}",
              "rightValue": "",
              "operator": {
                "type": "object",
                "operation": "notEmpty"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        2032,
        1024
      ],
      "id": "e509fd0c-eed6-458d-9eab-6e85b3d1becb",
      "name": "If"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://mgistrmwhxccyuchokbh.supabase.co/functions/v1/dynamic-hybrid-search",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n        \"query_text\": \"{{ $('When Executed by Another Workflow').item.json.query }}\",\n        \"query_embedding\": [{{ $json.data[0].embedding }}],\n        \"match_count\": 30,\n        \"filter\": {{ $('Prep Metadata1').isExecuted ? JSON.stringify($('Prep Metadata1').item.json.output.filter) : \"[]\" }},\n\"dense_weight\": {{ $('When Executed by Another Workflow').item.json.dense_weight }},\n\"sparse_weight\": {{ $('When Executed by Another Workflow').item.json.sparse_weight }},\n\"ilike_weight\": {{ $('When Executed by Another Workflow').item.json.ilike_weight }},\n\"fuzzy_weight\": {{ $('When Executed by Another Workflow').item.json.fuzzy_weight }},\n\"fuzzy_threshold\": {{ $('When Executed by Another Workflow').item.json.fuzzy_threshold }}\n      }",
        "options": {
          "redirect": {
            "redirect": {}
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        3168,
        944
      ],
      "id": "ea197840-345d-43e4-af0a-5f185459adff",
      "name": "Trigger Dynamic Hybrid Search",
      "alwaysOutputData": true,
      "credentials": {
        "supabaseApi": {
          "id": "JXvQLWfqIjdcMyqm",
          "name": "Supabase B5rman"
        }
      }
    },
    {
      "parameters": {
        "content": "## TODO\n### Add Edge Function URL\nYou can also change number of results returned",
        "height": 332,
        "width": 232
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        3104,
        800
      ],
      "id": "cc91afe8-eade-4219-8636-fbb66e046cfd",
      "name": "Sticky Note22"
    },
    {
      "parameters": {
        "content": "## TODO (Optional)\nYou can change the number of results returned",
        "height": 300,
        "width": 232
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        3920,
        800
      ],
      "id": "95647949-8406-4879-9da1-9721d70f02b2",
      "name": "Sticky Note23"
    },
    {
      "parameters": {
        "content": "",
        "height": 648,
        "width": 840,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        0,
        768
      ],
      "id": "fff3dc4d-a938-42d2-a38c-7783489eb95a",
      "name": "Sticky Note24"
    },
    {
      "parameters": {
        "content": "## v2.3.3\nThis it the retrieval sub-workflow for both our SOTA RAG System and RAG At Scale System\n\nSOTA RAG Setup instructions here:\nhttps://community.theaiautomators.com/c/automation-templates/state-of-the-art-n8n-rag-agent\n\nRAG at Scale Setup instructions here:\nhttps://community.theaiautomators.com/c/automation-templates/rag-at-scale-system",
        "height": 244,
        "width": 580,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        160,
        1136
      ],
      "id": "c5846d0b-daba-4c8f-a390-63357e5350f4",
      "name": "Sticky Note28"
    },
    {
      "parameters": {
        "content": "## TODO\n### Connect the Chat Trigger to your Agent of Choice",
        "height": 256,
        "width": 576
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        160,
        848
      ],
      "id": "e7f63a76-d4ad-4fa1-b509-1c045471e834",
      "name": "Sticky Note30"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "claude-haiku-4-5-20251001",
          "mode": "list",
          "cachedResultName": "Claude Haiku 4.5"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
      "typeVersion": 1.3,
      "position": [
        2464,
        1120
      ],
      "id": "2e078734-7112-4681-af01-79eac73287a1",
      "name": "Anthropic Chat Model",
      "credentials": {
        "anthropicApi": {
          "id": "UyAehXbUNQAWwZOs",
          "name": "Claude SEB"
        }
      }
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "claude-sonnet-4-6",
          "mode": "list",
          "cachedResultName": "Claude Sonnet 4.6"
        },
        "options": {
          "thinking": true,
          "thinkingBudget": 10000,
          "maxTokensToSample": 16000
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
      "typeVersion": 1.3,
      "position": [
        928,
        384
      ],
      "id": "2d3483f7-2a04-45fe-b65b-8c7165171570",
      "name": "Anthropic Chat Model3",
      "credentials": {
        "anthropicApi": {
          "id": "UyAehXbUNQAWwZOs",
          "name": "Claude SEB"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $('When chat message received').item.json.chatInput }}",
        "options": {
          "systemMessage": "=# Role\n\nYou are a RAG assistant that answers questions using a knowledgebase of documents and structured datasets.\n\n# Goal\n\nCreate and execute a retrieval strategy to answer the user's query. Your response must be fully grounded in the retrieved information — never fabricate content.\n\nConsider the conversation history alongside the current query.\n\n# Tools Available\n\n1. **Dynamic Hybrid Search** — Searches the vector store using a weighted combination of dense (semantic), sparse (lexical), ilike (exact match), and fuzzy search\n2. **Fetch Document Hierarchy** — Loads the full document structure (title, chunks, page ranges) from the record manager\n3. **Context Expansion** — Fetches neighbouring and parent chunks to expand context around relevant results\n4. **Query Tabular Rows** — Executes SQL queries against structured data (Excel, CSV, Google Sheets) stored in the tabular_document_rows table\n\n# Standard Operating Procedure\n\n## For document/text questions → Hybrid Search path\n\n1. Formulate your search query and call **Dynamic Hybrid Search**. Choose weights based on the query type:\n   - Semantic/natural language → prioritise dense (e.g. dense=0.7, sparse=0.3)\n   - Technical terms, keywords → prioritise sparse (e.g. dense=0.3, sparse=0.7)\n   - Exact codes, IDs, invoice numbers → use ilike (e.g. ilike=1.0)\n   - Misspellings or approximate terms → add fuzzy weight (e.g. dense=0.4, sparse=0.3, fuzzy=0.3)\n2. From the most relevant chunks, call **Fetch Document Hierarchy** to load the source document structure\n3. Using the document structure and the chunk metadata (child_ranges, parent_ranges), call **Context Expansion** to retrieve surrounding context\n4. If the first search didn't return strong results, try reformulating the query or adjusting the weights before answering\n\n## For numerical/tabular questions → SQL path\n\nIf the question involves calculations, aggregations, comparisons, or structured data (sums, averages, counts, rankings, max/min values), the vector store is unreliable for this. Use the SQL path instead:\n\n1. First, use **Dynamic Hybrid Search** with a query about the dataset topic to identify which documents contain relevant tabular data. Look for record_manager_id values in the results.\n2. Call **Query Tabular Rows** with SQL to answer the question. Always filter by record_manager_id.\n3. Before applying WHERE filters on specific values, run a SELECT DISTINCT query first to verify the exact values that exist in the data.\n\n## For mixed questions\n\nUse both paths. Retrieve contextual information from the hybrid search, and precise numbers from the SQL queries.\n\n# Response Rules\n\n- Format: Multiple paragraphs with markdown headings where appropriate\n- Respond in the same language as the user's question\n- Include images from retrieved results in markdown format if available\n- Maintain continuity with conversation history\n- If no relevant information is found after searching, say: \"I couldn't find information about that in the knowledgebase. Could you rephrase your question or let me know which document to look in?\"\n- Never include information not provided by the tools\n\n# Output Format (CRITICAL — you must follow this exactly)\n\nYour output must have TWO sections separated by the exact delimiter `---SOURCES_JSON---`.\n\n## Section 1: Answer\nWrite your full answer in markdown. Do NOT include a References section in the answer — that will be generated automatically from your structured sources.\n\n## Section 2: Sources JSON\nAfter the delimiter, output a JSON array of source objects. Each object represents a document you cited in your answer.\n\nRequired fields for each source object:\n- `doc_name` (string): The document name exactly as it appears in the chunk metadata\n- `doc_id` (string): The record_manager_id from the chunk metadata\n- `pages` (array of integers): Page numbers referenced, e.g. [1, 2, 5]. Use an empty array [] if pages are not available.\n- `chunk_indices` (array of integers): The chunk_index values from the chunks you used, e.g. [0, 3, 7]\n- `relevance` (string): A short phrase describing what this source contributed to the answer\n\n## Example Output\n\nHere is a detailed compliance report based on the retrieved documents...\n\n[Answer content continues here in markdown...]\n\n---SOURCES_JSON---\n[\n  {\n    \"doc_name\": \"Microsoft 365 Audit Report\",\n    \"doc_id\": \"abc123-def456\",\n    \"pages\": [3, 4, 12],\n    \"chunk_indices\": [5, 8, 22],\n    \"relevance\": \"Primary source for compliance findings\"\n  },\n  {\n    \"doc_name\": \"Security Policy Template\",\n    \"doc_id\": \"xyz789-ghi012\",\n    \"pages\": [1],\n    \"chunk_indices\": [0, 2],\n    \"relevance\": \"Referenced for baseline security requirements\"\n  }\n]\n\n## Source Rules\n- Only cite documents whose chunks were actually returned by the tools\n- Every factual claim in your answer must trace to at least one source\n- Use the exact `doc_name` and `doc_id` (record_manager_id) from the chunk metadata — do not modify or abbreviate them\n- The `chunk_indices` must be actual chunk_index values from the tool results\n- For tabular queries, use the dataset name as doc_name and the record_manager_id as doc_id"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.9,
      "position": [
        1312,
        144
      ],
      "id": "b1733a42-add2-4fcc-86a9-f0e7384f88e3",
      "name": "Agentic RAG 1 Beta",
      "retryOnFail": true,
      "maxTries": 5
    },
    {
      "parameters": {
        "description": "=Search the knowledgebase using hybrid search with 4 configurable components. The weights must total 1.0.\n\nParameters:\n  dense_weight  (default 0.5) — vector similarity, best for semantic/natural language queries\n  sparse_weight (default 0.5) — BM25 lexical search, best for keywords and technical terms\n  ilike_weight  (default 0)   — wildcard pattern matching, best for exact codes/IDs/references\n  fuzzy_weight  (default 0)   — fuzzy text matching, best for misspellings or approximate terms\n  fuzzy_threshold (default 0.8) — similarity threshold for fuzzy, higher = stricter but faster\n\nWeight strategies by query type:\n  General question     → dense=0.5, sparse=0.5\n  Semantic/conceptual  → dense=0.7, sparse=0.3\n  Technical/keyword    → dense=0.3, sparse=0.7\n  Exact ID or code     → ilike=1.0 (keep query very short, e.g. \"INV-2024-001\")\n  Misspelled term      → dense=0.4, sparse=0.3, fuzzy=0.3\n\nImportant:\n- For ilike and fuzzy: use a very short, focused query (1-3 words) or it will return zero results\n- ilike and fuzzy add latency — only use when needed, default them to 0\n- fuzzy_threshold: keep at 0.8 or higher to limit latency",
        "workflowId": {
          "__rl": true,
          "value": "Bgl5d3deLQufGLff",
          "mode": "list",
          "cachedResultUrl": "/workflow/Bgl5d3deLQufGLff",
          "cachedResultName": "RAG Retrieval Sub-Workflow v1.0.8c"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "query": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('query', ``, 'string') }}",
            "session_id": "={{ $json.sessionId }}",
            "sparse_weight": "={{ $fromAI('sparse_weight', ``, 'number', 0.5) }}",
            "dense_weight": "={{ $fromAI('dense_weight', ``, 'number', 0.5) }}",
            "fuzzy_threshold": "={{ $fromAI('fuzzy_threshold', `this is the word similarity threshold in postgres - lower means more candidates however the call may time out`, 'number', 0.8) }}",
            "fuzzy_weight": "={{ $fromAI('fuzzy_weight', ``, 'number', 0) }}",
            "ilike_weight": "={{ $fromAI('ilike_weight', ``, 'number', 0) }}",
            "type": "hybrid"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "query",
              "displayName": "query",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "type",
              "displayName": "type",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "session_id",
              "displayName": "session_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "dense_weight",
              "displayName": "dense_weight",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            },
            {
              "id": "sparse_weight",
              "displayName": "sparse_weight",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            },
            {
              "id": "ilike_weight",
              "displayName": "ilike_weight",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            },
            {
              "id": "fuzzy_weight",
              "displayName": "fuzzy_weight",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            },
            {
              "id": "fuzzy_threshold",
              "displayName": "fuzzy_threshold",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        }
      },
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "typeVersion": 2.2,
      "position": [
        1232,
        416
      ],
      "id": "28f2b0ea-8186-4f35-a2ea-73ef656ea546",
      "name": "Dynamic Hybrid Search3 - Beta"
    },
    {
      "parameters": {
        "descriptionType": "manual",
        "toolDescription": "Execute a SQL query on the tabular_document_rows table.\n\nEach row contains a row_data field (jsonb) with keys matching the source file's column headers.\n\nRules:\n- Always filter by record_manager_id to target a specific dataset\n- Extract values from row_data using the ->> operator (e.g. row_data->>'profit')\n- Cast to numeric for calculations: (row_data->>'profit')::numeric\n- Before applying WHERE filters on specific values, ALWAYS run SELECT DISTINCT first (LIMIT 100) to verify the exact values that exist in the data — even if the user provides a specific value\n- Do NOT run SELECT DISTINCT on ID columns\n\nExample: Maximum value\nSELECT MAX((row_data->>'profit')::numeric) AS max_profit\nFROM tabular_document_rows\nWHERE record_manager_id = 123;\n\nExample: Group and aggregate\nSELECT row_data->>'country' AS country,\n       SUM((row_data->>'revenue')::numeric) AS total_revenue\nFROM tabular_document_rows\nWHERE record_manager_id = 123\nGROUP BY row_data->>'country';\n\nExample: Filter with validation (run this first)\nSELECT DISTINCT row_data->>'region' AS region\nFROM tabular_document_rows\nWHERE record_manager_id = 123\nLIMIT 100;\n\n-- Then use the exact values returned:\nSELECT row_data->>'region' AS region,\n       AVG((row_data->>'sales')::numeric) AS avg_sales\nFROM tabular_document_rows\nWHERE record_manager_id = 123\n  AND row_data->>'region' = 'Europe'\nGROUP BY row_data->>'region';\n",
        "operation": "executeQuery",
        "query": "{{ $fromAI('sql_query') }}",
        "options": {}
      },
      "type": "n8n-nodes-base.postgresTool",
      "typeVersion": 2.5,
      "position": [
        1424,
        432
      ],
      "id": "5e896c1d-80f6-42ec-9e98-cd5c188cd513",
      "name": "Query Tabular Rows3 - Beta",
      "credentials": {
        "postgres": {
          "id": "tRlTzpjOmrCVSNLF",
          "name": "Postgres account"
        }
      }
    },
    {
      "id": "c194ec7d-6657-43f0-bdf0-f89e955208cb",
      "name": "Format & Verify Citations",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1712,
        144
      ],
      "parameters": {
        "jsCode": "// Format & Verify Citations — Phase 1\n// Splits agent output on ---SOURCES_JSON--- delimiter,\n// validates citation structure, builds clean References section.\n\nconst rawOutput = $input.item.json.output || $input.item.json.text || '';\nconst DELIMITER = '---SOURCES_JSON---';\nconst parts = rawOutput.split(DELIMITER);\n\nlet answer = (parts[0] || '').trim();\nlet sourcesRaw = (parts[1] || '').trim();\nlet sources = [];\nlet citationWarnings = [];\n\n// Parse the sources JSON\nif (sourcesRaw) {\n  try {\n    // Strip markdown code fences if the agent wrapped the JSON\n    sourcesRaw = sourcesRaw.replace(/^```json?\\s*/i, '').replace(/\\s*```\\s*$/, '');\n    sources = JSON.parse(sourcesRaw);\n    if (!Array.isArray(sources)) {\n      citationWarnings.push('sources_used was not an array; wrapped it');\n      sources = [sources];\n    }\n  } catch (e) {\n    citationWarnings.push(`Failed to parse sources JSON: ${e.message}`);\n    sources = [];\n  }\n} else {\n  citationWarnings.push('No ---SOURCES_JSON--- delimiter found in agent output');\n}\n\n// Validate each source object\nconst validSources = [];\nfor (const src of sources) {\n  const issues = [];\n  if (!src.doc_name || typeof src.doc_name !== 'string') issues.push('missing/invalid doc_name');\n  if (!src.doc_id || typeof src.doc_id !== 'string') issues.push('missing/invalid doc_id');\n  if (!Array.isArray(src.pages)) issues.push('missing/invalid pages array');\n  if (!Array.isArray(src.chunk_indices)) issues.push('missing/invalid chunk_indices');\n\n  if (issues.length === 0) {\n    validSources.push(src);\n  } else {\n    citationWarnings.push(`Source \"${src.doc_name || 'unknown'}\": ${issues.join(', ')}`);\n  }\n}\n\n// Build clean References section from validated sources\nlet referencesSection = '';\nif (validSources.length > 0) {\n  referencesSection = '\\n\\n## References\\n\\n';\n  validSources.forEach((src, idx) => {\n    const pages = src.pages.length > 0 ? ` (Pages: ${src.pages.join(', ')})` : '';\n    const relevance = src.relevance ? ` — ${src.relevance}` : '';\n    referencesSection += `${idx + 1}. **${src.doc_name}**${pages}${relevance}\\n`;\n  });\n} else if (answer && !answer.toLowerCase().includes(\"couldn't find information\")) {\n  citationWarnings.push('Agent produced an answer but no valid source citations');\n  referencesSection = '\\n\\n## References\\n\\n_No verified sources available for this response._\\n';\n}\n\n// Strip any References section the agent may have included in the answer body\nanswer = answer.replace(/\\n##?\\s*References[\\s\\S]*$/i, '').trim();\n\nconst finalOutput = answer + referencesSection;\n\nreturn {\n  json: {\n    output: finalOutput,\n    sources: validSources,\n    citationWarnings: citationWarnings,\n    sourceCount: validSources.length,\n    hasWarnings: citationWarnings.length > 0\n  }\n};"
      }
    }
  ],
  "connections": {
    "Supabase Short-Term Memory": {
      "ai_memory": [
        [
          {
            "node": "Agentic RAG 1 Beta",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Supabase Short-Term Memory2": {
      "ai_memory": [
        [
          {
            "node": "Agentic RAG 3",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Get Long Term Memories": {
      "main": [
        [
          {
            "node": "Agentic RAG 3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "user_id": {
      "main": [
        [
          {
            "node": "Get Long Term Memories",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Query Tabular Rows1": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 3",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Get datasets from record_manager1": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 3",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Query Knowledge Graph2": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 2",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Supabase Short-Term Memory3": {
      "ai_memory": [
        [
          {
            "node": "Agentic RAG 2",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Query Tabular Rows2": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 2",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Get datasets from record_manager2": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 2",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Anthropic Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "Agentic RAG 2",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Anthropic Chat Model2": {
      "ai_languageModel": [
        [
          {
            "node": "Agentic RAG 3",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Dynamic Hybrid Search1": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 2",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Dynamic Hybrid Search2": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 3",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Document Hierarchy": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 1 Beta",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Context Expansion": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 1 Beta",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Document Hierarchy1": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 2",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Context Expansion1": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 2",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Query Knowledge Graph1": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 3",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Document Hierarchy2": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 3",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Context Expansion2": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 3",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Agentic RAG 3": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          },
          {
            "node": "Execute workflow - Save Zep long term memories",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "When Executed by Another Workflow": {
      "main": [
        [
          {
            "node": "Switch2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Embedding From Query": {
      "main": [
        [
          {
            "node": "Trigger Dynamic Hybrid Search",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Rerank with Cohere 3.5": {
      "main": [
        [
          {
            "node": "Return Reordered Items1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Array": {
      "main": [
        [
          {
            "node": "Rerank with Cohere 3.5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If3": {
      "main": [
        [
          {
            "node": "Create Array",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch2": {
      "main": [
        [
          {
            "node": "Chat Memory Manager",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Query Graph",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Query Graph": {
      "main": [
        [
          {
            "node": "Tidy up response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Chat Memory Manager": {
      "main": [
        [
          {
            "node": "Fetch Metadata Fields1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prep Metadata1": {
      "main": [
        [
          {
            "node": "Generate Embedding From Query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser": {
      "ai_outputParser": [
        [
          {
            "node": "Prep Metadata1",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Metadata Fields1": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prep1": {
      "main": [
        [
          {
            "node": "Prep Metadata1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Supabase Short-Term Memory1": {
      "ai_memory": [
        [
          {
            "node": "Chat Memory Manager",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "Prep1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Generate Embedding From Query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Trigger Dynamic Hybrid Search": {
      "main": [
        [
          {
            "node": "If3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "When chat message received": {
      "main": [
        [
          {
            "node": "Agentic RAG 1 Beta",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Anthropic Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "Prep Metadata1",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Anthropic Chat Model3": {
      "ai_languageModel": [
        [
          {
            "node": "Agentic RAG 1 Beta",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Dynamic Hybrid Search3 - Beta": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 1 Beta",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Query Tabular Rows3 - Beta": {
      "ai_tool": [
        [
          {
            "node": "Agentic RAG 1 Beta",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Agentic RAG 1 Beta": {
      "main": [
        [
          {
            "node": "Format & Verify Citations",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "binaryMode": "separate",
    "availableInMCP": false,
    "callerPolicy": "workflowsFromSameOwner"
  }
}